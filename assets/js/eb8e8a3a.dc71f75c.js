"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[8363],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>h});var a=t(67294);function s(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){s(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,s=function(e,n){if(null==e)return{};var t,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||(s[t]=e[t]);return s}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(s[t]=e[t])}return s}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,s=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),m=l(t),h=s,g=m["".concat(c,".").concat(h)]||m[h]||p[h]||o;return t?a.createElement(g,r(r({ref:n},d),{},{components:t})):a.createElement(g,r({ref:n},d))}));function h(e,n){var t=arguments,s=n&&n.mdxType;if("string"==typeof e||s){var o=t.length,r=new Array(o);r[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:s,r[1]=i;for(var l=2;l<o;l++)r[l]=t[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},33826:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=t(87462),s=(t(67294),t(3905));const o={sidebar_position:6060,slug:"2021-09-09",title:"HAProxy Loadbalancing and Websockets",authors:"mpolinowski",tags:["Javascript"]},r=void 0,i={unversionedId:"Development/Javascript/2021-09-09--websocket-HAproxy/index",id:"Development/Javascript/2021-09-09--websocket-HAproxy/index",title:"HAProxy Loadbalancing and Websockets",description:"Wan Chai, Hong Kong",source:"@site/docs/Development/Javascript/2021-09-09--websocket-HAproxy/index.md",sourceDirName:"Development/Javascript/2021-09-09--websocket-HAproxy",slug:"/Development/Javascript/2021-09-09--websocket-HAproxy/2021-09-09",permalink:"/docs/Development/Javascript/2021-09-09--websocket-HAproxy/2021-09-09",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Development/Javascript/2021-09-09--websocket-HAproxy/index.md",tags:[{label:"Javascript",permalink:"/docs/tags/javascript"}],version:"current",sidebarPosition:6060,frontMatter:{sidebar_position:6060,slug:"2021-09-09",title:"HAProxy Loadbalancing and Websockets",authors:"mpolinowski",tags:["Javascript"]},sidebar:"tutorialSidebar",previous:{title:"NGINX as a Proxy for Websockets",permalink:"/docs/Development/Javascript/2021-09-09--websocket-NGINX/2021-09-09"},next:{title:"HTML Video over Websockets",permalink:"/docs/Development/Javascript/2021-09-08--websockets-html-video/2021-09-08"}},c={},l=[{value:"Build the Docker Image",id:"build-the-docker-image",level:2},{value:"Docker Compose",id:"docker-compose",level:2},{value:"Testing",id:"testing",level:2},{value:"WSS Adding TLS Encryption",id:"wss-adding-tls-encryption",level:2},{value:"Create a PEM Certificates",id:"create-a-pem-certificates",level:3},{value:"HAProxy Configuration",id:"haproxy-configuration",level:3},{value:"Spin up the Docker Composition",id:"spin-up-the-docker-composition",level:3},{value:"Testing",id:"testing-1",level:3},{value:"Debugging",id:"debugging",level:3}],d={toc:l};function p(e){let{components:n,...o}=e;return(0,s.kt)("wrapper",(0,a.Z)({},d,o,{components:n,mdxType:"MDXLayout"}),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Wan Chai, Hong Kong",src:t(52132).Z,width:"1500",height:"491"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#build-the-docker-image"},"Build the Docker Image")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#docker-compose"},"Docker Compose")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#testing"},"Testing")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#wss-adding-tls-encryption"},"WSS Adding TLS Encryption"),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#create-a-pem-certificates"},"Create a PEM Certificates")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#haproxy-configuration"},"HAProxy Configuration")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#spin-up-the-docker-composition"},"Spin up the Docker Composition")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#testing-1"},"Testing")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#debugging"},"Debugging"))))),(0,s.kt)("p",null,"Following along a tutorial by ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/hnasr/javascript_playground/tree/master/ws-live-chat-system"},"hnasr")," to check out how to use web proxies / load-balancing in front of applications that use websocket connections."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Project Structure")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"\u251c\u2500\u2500 app\n\u2502   \u251c\u2500\u2500 index.mjs\n\u2502   \u2514\u2500\u2500 package.json\n\u251c\u2500\u2500 docker-compose.yml\n\u251c\u2500\u2500 Dockerfile\n\u2514\u2500\u2500 haproxy\n    \u2514\u2500\u2500 haproxy.cfg\n")),(0,s.kt)("h2",{id:"build-the-docker-image"},"Build the Docker Image"),(0,s.kt)("p",null,"Build the chat app image with the following ",(0,s.kt)("strong",{parentName:"p"},"Dockerfile"),":"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-Dockerfile"},"FROM node:13\nWORKDIR /home/node/app\nCOPY app /home/node/app\nRUN npm install\nCMD npm run app\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"docker build -t wsapp .\n\n[+] Building 63.7s (10/10) FINISHED\n => [internal] load build definition from Dockerfile                                                               0.1s\n => => transferring dockerfile: 130B                                                                               0.0s\n => [internal] load .dockerignore                                                                                  0.1s\n => => transferring context: 2B                                                                                    0.0s\n => [internal] load metadata for docker.io/library/node:13                                                        10.4s\n => [auth] library/node:pull token for registry-1.docker.io                                                        0.0s\n => [1/4] FROM docker.io/library/node:13@sha256:70d4fffcab39a1f9f7161d58e674ddcc56c7f0724196b68d52a87bab15cb4a04  46.0s\n => => resolve docker.io/library/node:13@sha256:70d4fffcab39a1f9f7161d58e674ddcc56c7f0724196b68d52a87bab15cb4a04   0.0s\n => => sha256:1c6172af85ee14a8db5a3a51d406b768dfa94d196c06d0d06d591507cf8199f0 45.38MB / 45.38MB                   7.6s\n => => sha256:b194b0e3c928807cfabf081055a117585ba5bf6697f65b2fede02225a5d73ad2 10.80MB / 10.80MB                   6.0s\n => => sha256:70d4fffcab39a1f9f7161d58e674ddcc56c7f0724196b68d52a87bab15cb4a04 1.21kB / 1.21kB                     0.0s\n => => sha256:1e8d7127072cdbaae1935656444c3ec2bef8882c8c14d459e3a92ca1dd313c28 2.21kB / 2.21kB                     0.0s\n => => sha256:2b9604a36e4911d15d2916dac4f1d853e2da612e9bb77df1016f8a51b3e333a1 7.88kB / 7.88kB                     0.0s\n => => sha256:1f5ec00f35d5b2d1db6b8e925a3005c1a285365775028db0339903ddaeec4763 4.34MB / 4.34MB                     4.0s\n => => sha256:93b1353672b6861da5f1b58b0eca02ec10373a25d2898bddafa1b4bae2271c55 50.08MB / 50.08MB                  19.0s\n => => sha256:3d7f38db3cca2c74df9a146d8419f5bf79d79b18de9eaee6351dccde16ab1f4a 214.91MB / 214.91MB                34.5s\n => => sha256:21e102f9fe89a18627c0ce50945bd1e0a11d0fecd4800bbbd999944d3940efc6 4.16kB / 4.16kB                     8.5s\n => => extracting sha256:1c6172af85ee14a8db5a3a51d406b768dfa94d196c06d0d06d591507cf8199f0                          2.6s\n => => sha256:d5431b24825a3297da35afe3d32786e01ec3fe7a8d1685adf59f82138e916e10 34.44MB / 34.44MB                  19.1s\n => => extracting sha256:b194b0e3c928807cfabf081055a117585ba5bf6697f65b2fede02225a5d73ad2                          0.5s\n => => extracting sha256:1f5ec00f35d5b2d1db6b8e925a3005c1a285365775028db0339903ddaeec4763                          0.2s\n => => extracting sha256:93b1353672b6861da5f1b58b0eca02ec10373a25d2898bddafa1b4bae2271c55                          3.3s\n => => sha256:f780e3352c1809c08a5e6e4168206425ce703018baae8d6efd8d18efb101405b 2.38MB / 2.38MB                    22.3s\n => => sha256:4d28937582d0e76cbe8ed78ed921823a349a8a0755f91e13648e7636c974b0b6 295B / 295B                        21.1s\n => => extracting sha256:3d7f38db3cca2c74df9a146d8419f5bf79d79b18de9eaee6351dccde16ab1f4a                          8.6s\n => => extracting sha256:21e102f9fe89a18627c0ce50945bd1e0a11d0fecd4800bbbd999944d3940efc6                          0.0s\n => => extracting sha256:d5431b24825a3297da35afe3d32786e01ec3fe7a8d1685adf59f82138e916e10                          1.7s\n => => extracting sha256:f780e3352c1809c08a5e6e4168206425ce703018baae8d6efd8d18efb101405b                          0.1s\n => => extracting sha256:4d28937582d0e76cbe8ed78ed921823a349a8a0755f91e13648e7636c974b0b6                          0.0s\n => [internal] load build context                                                                                  0.1s\n => => transferring context: 2.65kB                                                                                0.0s\n => [2/4] WORKDIR /home/node/app                                                                                   1.2s\n => [3/4] COPY app /home/node/app                                                                                  0.1s\n => [4/4] RUN npm install                                                                                          5.7s\n => exporting to image                                                                                             0.2s\n => => exporting layers                                                                                            0.2s\n => => writing image sha256:1d2f01e0f5cabc7d8fa5c453c16546f2bf192daf8dfec351797562052b861026                       0.0s\n => => naming to docker.io/library/wsapp\n")),(0,s.kt)("p",null,"This will download the Node.js v13 Docker image as a base and install/run the content of the folder ",(0,s.kt)("strong",{parentName:"p"},"app")," inside the container. This folder contains a ",(0,s.kt)("inlineCode",{parentName:"p"},"package.json")," file with our app dependencies:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "app",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.mjs",\n  "scripts": {\n    "app": "node index.mjs"\n  },\n  "keywords": [],\n  "author": "",\n  "license": "ISC",\n  "dependencies": {\n    "http": "0.0.1-security",\n    "redis": "^3.0.2",\n    "websocket": "^1.0.31"\n  }\n}\n')),(0,s.kt)("p",null,"And execute the file ",(0,s.kt)("inlineCode",{parentName:"p"},"index.mjs")," with the Websocket Server code as soon as the Container is run:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-js"},'import http from "http";\nimport ws from "websocket"\nimport redis from "redis";\nconst APPID = process.env.APPID;\nlet connections = [];\nconst WebSocketServer = ws.server\n\n// Clients will be connected to different instances of our service. To allow them to interact we need to connect our app to a Redis database "redistribute" our app state, i.e. messages written on server 1 will be available on server 2 since all apps store their messages in a single place from where all instances can read incoming updates.\n\nconst subscriber = redis.createClient({\n  port      : 6379,              \n  host      : \'rds\'} );\n\nconst publisher = redis.createClient({\n  port      : 6379,              \n  host      : \'rds\'} );\n  \n\n// Subscribe the app to the Redis backend\n\nsubscriber.subscribe("livechat");\n\n// When a subscription is successful publish a success message\n\nsubscriber.on("subscribe", function(channel, count) {\n  console.log(`Server ${APPID} subscribed successfully to livechat`)\n  publisher.publish("livechat", "a message");\n});\n\n// If a message comes in to Redis "livechat" subscription publish it to all active websocket connections\n\nsubscriber.on("message", function(channel, message) {\n  try{\n  //when we receive a message I want t\n  console.log(`Server ${APPID} received message in channel ${channel} msg: ${message}`);\n  connections.forEach(c => c.send(APPID + ":" + message))\n    \n  }\n  catch(ex){\n    console.log("ERR::" + ex)\n  }\n});\n\n\n// Create a raw http server that will negotiate the websocket connection\nconst httpserver = http.createServer()\n\n// Pass the httpserver object to the WebSocketServer library\nconst websocket = new WebSocketServer({\n    "httpServer": httpserver\n})\n\n\nhttpserver.listen(8080, () => console.log("My server is listening on port 8080"))\n\n//when a legit websocket request comes in establish a connection\nwebsocket.on("request", request=> {\n\n    const con = request.accept(null, request.origin)\n    con.on("open", () => console.log("opened"))\n    con.on("close", () => console.log("CLOSED!!!"))\n    con.on("message", message => {\n        //publish the message to redis\n        console.log(`${APPID} Received message ${message.utf8Data}`)\n        publisher.publish("livechat", message.utf8Data)\n    })\n\n    setTimeout(() => con.send(`Connected successfully to server ${APPID}`), 5000)\n    connections.push(con)\n  \n\n})\n  \n//client code \n//let ws = new WebSocket("ws://localhost:8080");\n//ws.onmessage = message => console.log(`Received: ${message.data}`);\n//ws.send("Hello! I\'m client")\n\n\n/*\n    //code clean up after closing connection\n    subscriber.unsubscribe();\n    subscriber.quit();\n    publisher.quit();\n    */\n')),(0,s.kt)("h2",{id:"docker-compose"},"Docker Compose"),(0,s.kt)("p",null,"The entire app will consist of a ",(0,s.kt)("a",{parentName:"p",href:"http://www.haproxy.org"},"HAProxy")," ",(0,s.kt)("inlineCode",{parentName:"p"},"haproxy")," that will divide the incoming traffic over all instances of our Websocket Chat App that we build above (I limited it to 2 instances ",(0,s.kt)("inlineCode",{parentName:"p"},"ws1")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"ws2")," - you can start as many as you need). Since every connecting users might be connected to different chat servers we need to add a database ",(0,s.kt)("inlineCode",{parentName:"p"},"redis")," in the background that all servers are connected to and exchange their state. This allows users to interact with each other - no matter what server they are connected to:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yml"},"version : '3'\n\nservices:\n    lb:\n        image: haproxy\n        ports:\n            - \"8080:8080\"\n        volumes:\n            - ./haproxy:/usr/local/etc/haproxy\n    ws1:\n        image: wsapp\n        environment:\n            - APPID=1111\n    ws2:\n        image: wsapp\n        environment:\n            - APPID=2222\n    rds:\n        image: redis\n")),(0,s.kt)("p",null,"The HAProxy container loads in a simple configuration file from the ",(0,s.kt)("inlineCode",{parentName:"p"},"./haproxy")," directory telling it that it should expect incoming traffic on port ",(0,s.kt)("inlineCode",{parentName:"p"},"8080")," and distribute them over our two chat apps:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yml"},"frontend http\n    bind *:8080\n    mode http\n    timeout client 1000s\n    use_backend all\n\nbackend all\n    mode http\n    timeout server 1000s\n    timeout connect 1000s \n    server s1 ws1:8080\n    server s2 ws2:8080\n")),(0,s.kt)("p",null,"To spin everything up run:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose up\n\nCreating network \"websocket_default\" with the default driver\nCreating websocket_ws1_1 ... done\nCreating websocket_ws2_1 ... done\nCreating websocket_lb_1  ... done\nCreating websocket_rds_1 ... done\nAttaching to websocket_ws1_1, websocket_rds_1, websocket_ws2_1, websocket_lb_1\nrds_1  | 1:C 23 Sep 2021 06:29:49.716 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\nrds_1  | 1:C 23 Sep 2021 06:29:49.716 # Redis version=6.2.5, bits=64, commit=00000000, modified=0, pid=1, just started\nrds_1  | 1:C 23 Sep 2021 06:29:49.716 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf\nrds_1  | 1:M 23 Sep 2021 06:29:49.717 * monotonic clock: POSIX clock_gettime\nrds_1  | 1:M 23 Sep 2021 06:29:49.718 * Running mode=standalone, port=6379.\nrds_1  | 1:M 23 Sep 2021 06:29:49.718 # Server initialized\nrds_1  | 1:M 23 Sep 2021 06:29:49.718 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\nrds_1  | 1:M 23 Sep 2021 06:29:49.718 * Ready to accept connections\nlb_1   | [NOTICE]   (1) : New worker #1 (8) forked\nws2_1  | \nws2_1  | > app@1.0.0 app /home/node/app\nws2_1  | > node index.mjs\nws2_1  | \nws1_1  | \nws1_1  | > app@1.0.0 app /home/node/app\nws1_1  | > node index.mjs\nws1_1  | \nws2_1  | My server is listening on port 8080\nws2_1  | Server 2222 subscribed successfully to livechat\nws2_1  | Server 2222 received message in channel livechat msg: a message\nws1_1  | My server is listening on port 8080\nws1_1  | Server 1111 subscribed successfully to livechat\nws2_1  | Server 2222 received message in channel livechat msg: a message\nws1_1  | Server 1111 received message in channel livechat msg: a message\n")),(0,s.kt)("h2",{id:"testing"},"Testing"),(0,s.kt)("p",null,"I started up the service on a server on my network with the IP address ",(0,s.kt)("inlineCode",{parentName:"p"},"192.168.2.111"),". So I can now open up the Chrome developer tools, switch to the ",(0,s.kt)("em",{parentName:"p"},"Console")," tab and connect to the service:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'let ws = new WebSocket("ws://192.168.2.111:8080");\nws.onmessage = message => console.log(`Received: ${message.data}`);\nws.send("Hello! I\'m client")\n')),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(26555).Z,width:"913",height:"213"})),(0,s.kt)("p",null,"You can see that the response I am getting from the service is:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"Received: 1111:Hello! I'm client\n")),(0,s.kt)("p",null,"This means that I am connected to the Websocket Chat App with the ",(0,s.kt)("strong",{parentName:"p"},"APPID 1111"),". Opening up a second browser and going to the same steps again will connect me to ",(0,s.kt)("strong",{parentName:"p"},"APPID 2222")," in a ",(0,s.kt)("inlineCode",{parentName:"p"},"round-robin")," fashion:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(20467).Z,width:"907",height:"646"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"Received: 2222:Hello! I'm client2\n")),(0,s.kt)("p",null,"It works!"),(0,s.kt)("h2",{id:"wss-adding-tls-encryption"},"WSS Adding TLS Encryption"),(0,s.kt)("h3",{id:"create-a-pem-certificates"},"Create a PEM Certificates"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"cd ./haproxy\n")),(0,s.kt)("p",null,"Generate a unique private key (KEY)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"openssl genrsa -out ws_haproxy.key 2048\n")),(0,s.kt)("p",null,"Generate a Certificate Signing Request (CSR)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"openssl req -new -key ws_haproxy.key -out ws_haproxy.csr\n\nYou are about to be asked to enter information that will be incorporated\ninto your certificate request.\nWhat you are about to enter is what is called a Distinguished Name or a DN.\nThere are quite a few fields but you can leave some blank\nFor some fields there will be a default value,\nIf you enter '.', the field will be left blank.\n-----\nCountry Name (2 letter code) [AU]:\nState or Province Name (full name) [Some-State]:\nLocality Name (eg, city) []:\nOrganization Name (eg, company) [Internet Widgits Pty Ltd]:\nOrganizational Unit Name (eg, section) []:\nCommon Name (e.g. server FQDN or YOUR name) []:192.168.2.111\nEmail Address []:\n\nPlease enter the following 'extra' attributes\nto be sent with your certificate request\nA challenge password []:\nAn optional company name []:\n")),(0,s.kt)("p",null,"Create a Self-Signed Certificate (CRT)"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"openssl x509 -req -days 365 -in ws_haproxy.csr -signkey ws_haproxy.key -out ws_haproxy.crt\n\nSignature ok\nsubject=C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = 192.168.2.111\nGetting Private key\n")),(0,s.kt)("p",null,"Append KEY and CRT to ",(0,s.kt)("inlineCode",{parentName:"p"},"ws_haproxy.pem")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"bash -c 'cat ws_haproxy.key ws_haproxy.crt >> ws_haproxy.pem'\n")),(0,s.kt)("p",null,"Specify PEM in haproxy config"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"nano haproxy.cfg\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yml"},"listen haproxy\n  bind 0.0.0.0:443 ssl crt /etc/ssl/private/ws_haproxy.pem\n")),(0,s.kt)("h3",{id:"haproxy-configuration"},"HAProxy Configuration"),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"./haproxy/haproxy_ssl.cfg")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yml"},"frontend ws\n    mode http\n    bind *:80\n    bind *:443 ssl crt /etc/ssl/private/ws_haproxy.pem\n    timeout client 1000s\n    default_backend wsbackend\n\nbackend wsbackend\n    mode http\n    server s1 ws1:8080\n    server s2 ws2:8080\n    timeout connect 1000s \n    timeout server 1000s\n")),(0,s.kt)("h3",{id:"spin-up-the-docker-composition"},"Spin up the Docker Composition"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yml"},'version : \'3\'\n\nservices:\n    lb:\n        image: haproxy\n        ports:\n            - "80:80"\n            - "443:443"\n        volumes:\n            - ./haproxy/haproxy_ssl.cfg:/usr/local/etc/haproxy/haproxy.cfg\n            - ./haproxy/ws_haproxy.pem:/etc/ssl/private/ws_haproxy.pem\n    ws1:\n        image: wsapp\n        environment:\n            - APPID=1111\n    ws2:\n        image: wsapp\n        environment:\n            - APPID=2222\n    rds:\n        image: redis\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose up\n\nRecreating websocket_lb_1 ... done\nStarting websocket_rds_1  ... done\nStarting websocket_ws2_1  ... done\nStarting websocket_ws1_1  ... done\nAttaching to websocket_rds_1, websocket_ws2_1, websocket_ws1_1, websocket_lb_1\nrds_1  | 1:C 24 Sep 2021 05:42:47.109 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo\nrds_1  | 1:C 24 Sep 2021 05:42:47.109 # Redis version=6.2.5, bits=64, commit=00000000, modified=0, pid=1, just started\nrds_1  | 1:C 24 Sep 2021 05:42:47.109 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf\nrds_1  | 1:M 24 Sep 2021 05:42:47.110 * monotonic clock: POSIX clock_gettime\nrds_1  | 1:M 24 Sep 2021 05:42:47.110 * Running mode=standalone, port=6379.\nrds_1  | 1:M 24 Sep 2021 05:42:47.110 # Server initialized\nrds_1  | 1:M 24 Sep 2021 05:42:47.110 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.\nrds_1  | 1:M 24 Sep 2021 05:42:47.111 * Loading RDB produced by version 6.2.5\nrds_1  | 1:M 24 Sep 2021 05:42:47.111 * RDB age 74 seconds\nrds_1  | 1:M 24 Sep 2021 05:42:47.111 * RDB memory usage when created 0.85 Mb\nrds_1  | 1:M 24 Sep 2021 05:42:47.111 * DB loaded from disk: 0.000 seconds\nrds_1  | 1:M 24 Sep 2021 05:42:47.111 * Ready to accept connections\nlb_1   | [NOTICE]   (1) : New worker #1 (9) forked\nws2_1  | \nws2_1  | > app@1.0.0 app /home/node/app\nws2_1  | > node index.mjs\nws2_1  | \nws1_1  | \nws1_1  | > app@1.0.0 app /home/node/app\nws1_1  | > node index.mjs\nws1_1  | \nws1_1  | My server is listening on port 8080\nws2_1  | My server is listening on port 8080\nws1_1  | Server 1111 subscribed successfully to livechat\nws1_1  | Server 1111 received message in channel livechat msg: a message\nws2_1  | Server 2222 subscribed successfully to livechat\nws1_1  | Server 1111 received message in channel livechat msg: a message\nws2_1  | Server 2222 received message in channel livechat msg: a message\n")),(0,s.kt)("h3",{id:"testing-1"},"Testing"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'let ws = new WebSocket("ws://192.168.2.111:80");\nws.onmessage = message => console.log(`Received: ${message.data}`);\nws.send("Hello! This chat is not secure");\n')),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(91337).Z,width:"1029",height:"186"})),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'let ws = new WebSocket("wss://192.168.2.111:443");\nws.onmessage = message => console.log(`Received: ${message.data}`);\nws.send("Hello! This chat is secure");\n')),(0,s.kt)("p",null,"But I cannot get a connection over a secure websocket:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(55514).Z,width:"1019",height:"383"})),(0,s.kt)("p",null,"I thought this might be an issue with the self-signed certificate and found the option in Firefox ",(0,s.kt)("inlineCode",{parentName:"p"},"about:config")," to set ",(0,s.kt)("inlineCode",{parentName:"p"},"network.websocket.allowInsecureFromHTTPS")," to ",(0,s.kt)("strong",{parentName:"p"},"true"),":"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(96621).Z,width:"1281",height:"195"})),(0,s.kt)("p",null,"But it still refused to connect hmmm. I checked the container everything is running. Also when I try accessing ",(0,s.kt)("inlineCode",{parentName:"p"},"https://192.168.2.111")," I am getting the typical warning that this site uses a self-signed cert. So HAProxy is working but I am still not getting wss connection..."),(0,s.kt)("h3",{id:"debugging"},"Debugging"),(0,s.kt)("p",null,"I am going to use Wireshark to see what is happening here:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(47744).Z,width:"959",height:"392"})),(0,s.kt)("p",null,"For the non-TLS connection I can see the HTTP GET with Upgrade Header. And the acknowledgement from the server to switch to Websockets:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(44247).Z,width:"963",height:"599"})),(0,s.kt)("p",null,"I can see the message that I send and a little bit below (below the SSH packages) the response from the server:"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(27185).Z,width:"961",height:"765"})),(0,s.kt)("p",null,"But when I switch to TLS all I see is the client handshaking the server - but the 3rd step does not seem to work, the server re-transmits the acknowledgement but my client (on IP ",(0,s.kt)("inlineCode",{parentName:"p"},"192.168.2.112"),") replies with a ",(0,s.kt)("strong",{parentName:"p"},"TCP ZeroWindow")," - which afaik is a ",(0,s.kt)("em",{parentName:"p"},'"Shut up, I am not listening"'),":"),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Websocket Chat Client",src:t(82658).Z,width:"1351",height:"345"})),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"I think I will have to try this on an online server, with a CA Cert and rule out that my local IP + self-signed cert aren't the issue why this is blocked.")))}p.isMDXComponent=!0},26555:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_01-b840f4930ba657d9f83a35807de4d2b8.png"},20467:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_02-fa4d151636311335411d89e5674fa089.png"},91337:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_03-0a7eddbdfa7c0f01b06eb41fb706fbfe.png"},55514:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_04-0a96c7edad4d0fb5e81940b3a238c9f7.png"},96621:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_05-ffcfe4afbbfee5a1452c9ab3ce1ca6df.png"},47744:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_06-164fb47a7da8fd014110f6f5fda3c929.png"},44247:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_07-caab3886fb187b5db9fe09432f4d1f77.png"},27185:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_08-789b4ac489e96c920771cf74c4e317f4.png"},82658:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/Websocket_Chat_Client_09-bb9cb63c44c107c8d330242e3688b25c.png"},52132:(e,n,t)=>{t.d(n,{Z:()=>a});const a=t.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-7e32a42d5f5edfd81c766627f025fa06.jpg"}}]);