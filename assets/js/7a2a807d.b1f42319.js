"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[6076],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},k=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=p(e,["components","mdxType","originalType","parentName"]),k=l(n),m=a,u=k["".concat(s,".").concat(m)]||k[m]||c[m]||o;return n?r.createElement(u,i(i({ref:t},d),{},{components:n})):r.createElement(u,i({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=k;var p={};for(var s in t)hasOwnProperty.call(t,s)&&(p[s]=t[s]);p.originalType=e,p.mdxType="string"==typeof e?e:a,i[1]=p;for(var l=2;l<o;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}k.displayName="MDXCreateElement"},20947:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>p,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const o={sidebar_position:7040,slug:"2020-09-02",title:"Docker Compose Networking",authors:"mpolinowski",tags:["LINUX","NGINX","Docker"]},i=void 0,p={unversionedId:"DevOps/Provisioning/2020-09-02--docker-compose-networking/index",id:"DevOps/Provisioning/2020-09-02--docker-compose-networking/index",title:"Docker Compose Networking",description:"Victoria Harbour, Hong Kong",source:"@site/docs/DevOps/Provisioning/2020-09-02--docker-compose-networking/index.md",sourceDirName:"DevOps/Provisioning/2020-09-02--docker-compose-networking",slug:"/DevOps/Provisioning/2020-09-02--docker-compose-networking/2020-09-02",permalink:"/docs/DevOps/Provisioning/2020-09-02--docker-compose-networking/2020-09-02",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/DevOps/Provisioning/2020-09-02--docker-compose-networking/index.md",tags:[{label:"LINUX",permalink:"/docs/tags/linux"},{label:"NGINX",permalink:"/docs/tags/nginx"},{label:"Docker",permalink:"/docs/tags/docker"}],version:"current",sidebarPosition:7040,frontMatter:{sidebar_position:7040,slug:"2020-09-02",title:"Docker Compose Networking",authors:"mpolinowski",tags:["LINUX","NGINX","Docker"]},sidebar:"tutorialSidebar",previous:{title:"Installing OpenProject with Docker Compose",permalink:"/docs/DevOps/Provisioning/2020-10-01--installing-openproject-in-docker/2020-10-01"},next:{title:"Serving Static Files with Hapi and Docker",permalink:"/docs/DevOps/Provisioning/2020-08-29--static-server-with-hapi-and-docker/2020-08-29"}},s={},l=[{value:"Docker Compose",id:"docker-compose",level:2},{value:"Manual Network Override",id:"manual-network-override",level:2}],d={toc:l};function c(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Victoria Harbour, Hong Kong",src:n(42874).Z,width:"1500",height:"509"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#docker-compose"},"Docker Compose")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#manual-network-override"},"Manual Network Override"))),(0,a.kt)("p",null,"I previously created 3 apps that are proxied by NGINX - all together 4 docker container waiting to be deployed. I now want to create a ",(0,a.kt)("strong",{parentName:"p"},"Docker Compose")," file to be able to start all of them up with a single command."),(0,a.kt)("h2",{id:"docker-compose"},"Docker Compose"),(0,a.kt)("p",null,"My first attempt to accomplish this looks like that - every wiki container runs the hapi web server and serves the content of ",(0,a.kt)("inlineCode",{parentName:"p"},"wiki/public")," which is mapped to a folder on my host system that contains the static web content from my app (that is source controlled by Gitlab and build in a Gitlab CI Pipeline). The NGINX proxy is then used to help out with the domain assignment and TLS certification:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yml"},"version: '3.8'\nservices:\n  wiki_en:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_en\n    ports:\n      - '127.0.0.1:7777:8888'\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-en/public:/wiki/public\n\n  wiki_fr:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_fr\n    ports:\n      - '127.0.0.1:7778:8888'\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-fr/public:/wiki/public\n\n  wiki_de:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_de\n    ports:\n      - '127.0.0.1:7779:8888'\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-de/public:/wiki/public\n\n  ingress:\n    image: nginx:stable-alpine\n    container_name: ingress\n    network_mode: host\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/docker_ingress:/etc/nginx/conf.d\n")),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note")," that I am running into an issue where NGINX has to access the public dir of each app (long story). This directory lies outside of the app container on my host system. This is why I have to forward ports for each app to my host network where NGINX is running. To prevent my apps from leaking onto the external network I will bind them to 127.0.0.1 on my host system.")),(0,a.kt)("p",null,"When I start this composite it will automatically create a virtual network for me - named after the folder that contains my ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file (",(0,a.kt)("strong",{parentName:"p"},"wiki"),"):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker network ls\n")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"NETWORK ID"),(0,a.kt)("td",{parentName:"tr",align:null},"NAME"),(0,a.kt)("td",{parentName:"tr",align:null},"DRIVER"),(0,a.kt)("td",{parentName:"tr",align:null},"SCOPE")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"d61bea58e174"),(0,a.kt)("td",{parentName:"tr",align:null},"bridge"),(0,a.kt)("td",{parentName:"tr",align:null},"bridge"),(0,a.kt)("td",{parentName:"tr",align:null},"local")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"c8cc528dc050"),(0,a.kt)("td",{parentName:"tr",align:null},"host"),(0,a.kt)("td",{parentName:"tr",align:null},"host"),(0,a.kt)("td",{parentName:"tr",align:null},"local")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"a982d8cfae58"),(0,a.kt)("td",{parentName:"tr",align:null},"none"),(0,a.kt)("td",{parentName:"tr",align:null},"null"),(0,a.kt)("td",{parentName:"tr",align:null},"local")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"545b0454b47f"),(0,a.kt)("td",{parentName:"tr",align:null},"wiki_default"),(0,a.kt)("td",{parentName:"tr",align:null},"bridge"),(0,a.kt)("td",{parentName:"tr",align:null},"local")))),(0,a.kt)("p",null,"Inspecting the network shows me that all applications have been attached to it at start up:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker inspect network wiki_default\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "Name": "wiki_default",\n    "Scope": "local",\n    "Driver": "bridge",\n    "EnableIPv6": false,\n    "Ingress": false,\n    "Containers": {\n      "44665": {\n        "Name": "wiki_de",\n        "MacAddress": "02:42:ac:12:00:04",\n        "IPv4Address": "172.18.0.4/16",\n        "IPv6Address": ""\n      },\n      "bca6e": {\n        "Name": "wiki_fr",\n        "MacAddress": "02:42:ac:12:00:03",\n        "IPv4Address": "172.18.0.3/16",\n        "IPv6Address": ""\n      },\n      "e98fdb": {\n        "Name": "wiki_en",\n        "MacAddress": "02:42:ac:12:00:02",\n        "IPv4Address": "172.18.0.2/16",\n        "IPv6Address": ""\n      }\n    }\n  }\n]\n')),(0,a.kt)("h2",{id:"manual-network-override"},"Manual Network Override"),(0,a.kt)("p",null,"You can override the default network name by adding a project name:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"docker-compose -p wiki_project up -d\n")),(0,a.kt)("p",null,"You can also specify the network in your ",(0,a.kt)("inlineCode",{parentName:"p"},"docker-compose.yml")," file. But before I start with that - let's figure out a way how I can remove the requirement for my NGINX ingress to be attached to my host network."),(0,a.kt)("p",null,"For example we can try to mount the ",(0,a.kt)("inlineCode",{parentName:"p"},"public")," directory of each app into the NGINX container and serve static content from there. I then also have to bring the NGINX container into my custom network and have it access my apps through the Docker DNS service."),(0,a.kt)("p",null,"The NGINX configuration file I use together the NGINX container will then look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cfg"},'server {\n    listen       80;\n    listen  [::]:80;\n    server_name  localhost;\n\n    charset koi8-r;\n\n    # Gzip Compression\n    gzip                                    on;\n    gzip_disable                            "MSIE [1-6]\\.(?!.*SV1)";\n    gzip_proxied                            no-cache no-store private expired;\n    gzip_buffers                            16 8k;\n    gzip_comp_level                         6;\n    gzip_types                              text/plain application/javascript application/x-javascript text/javascript text/xml text/css;\n    gzip_vary                               on;\n\n    location / {\n        rewrite   ^/(.*)$  /en/$1  permanent;\n    }\n\n    root                                        /opt/wiki/wiki-en/public;\n\n    location /en/ {\n        add_header                              Cache-Control  "public, must-revalidate, proxy-revalidate, max-age=0";\n        proxy_set_header                        X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header                        X-NginX-Proxy true;\n        proxy_set_header                        X-Real-IP $remote_addr;\n        proxy_set_header                        X-Forwarded-Proto http;\n        proxy_hide_header                       X-Frame-Options;\n        proxy_set_header                        Accept-Encoding "";\n        proxy_http_version                      1.1;\n        proxy_set_header                        Upgrade $http_upgrade;\n        proxy_set_header                        Connection "upgrade";\n        proxy_set_header                        Host $host;\n        proxy_cache_bypass                      $http_upgrade;\n        proxy_max_temp_file_size                0;\n        proxy_redirect                          off;\n        proxy_read_timeout                      240s;\n        proxy_pass                              http://wiki_en:7777/;\n    }\n\n    location /fr/ {\n        add_header                              Cache-Control  "public, must-revalidate, proxy-revalidate, max-age=0";\n        proxy_set_header                        X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header                        X-NginX-Proxy true;\n        proxy_set_header                        X-Real-IP $remote_addr;\n        proxy_set_header                        X-Forwarded-Proto http;\n        proxy_hide_header                       X-Frame-Options;\n        proxy_set_header                        Accept-Encoding "";\n        proxy_http_version                      1.1;\n        proxy_set_header                        Upgrade $http_upgrade;\n        proxy_set_header                        Connection "upgrade";\n        proxy_set_header                        Host $host;\n        proxy_cache_bypass                      $http_upgrade;\n        proxy_max_temp_file_size                0;\n        proxy_redirect                          off;\n        proxy_read_timeout                      240s;\n        proxy_pass                              http://wiki_fr:7778/;\n        root                                    /opt/wiki/wiki-fr/public;\n    }\n\n    location /de/ {\n        add_header                              Cache-Control  "public, must-revalidate, proxy-revalidate, max-age=0";\n        proxy_set_header                        X-Forwarded-For $proxy_add_x_forwarded_for;\n        proxy_set_header                        X-NginX-Proxy true;\n        proxy_set_header                        X-Real-IP $remote_addr;\n        proxy_set_header                        X-Forwarded-Proto http;\n        proxy_hide_header                       X-Frame-Options;\n        proxy_set_header                        Accept-Encoding "";\n        proxy_http_version                      1.1;\n        proxy_set_header                        Upgrade $http_upgrade;\n        proxy_set_header                        Connection "upgrade";\n        proxy_set_header                        Host $host;\n        proxy_cache_bypass                      $http_upgrade;\n        proxy_max_temp_file_size                0;\n        proxy_redirect                          off;\n        proxy_read_timeout                      240s;\n        proxy_pass                              http://wiki_de:7779/;\n        root                                    /opt/wiki/wiki-de/public;\n    }\n\n    error_page  404              /de/404.html;\n\n    # redirect server error pages to the static page /50x.html\n    #\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n    root   /usr/share/nginx/html;\n    }\n}\n')),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"Note")," that now, instead of having a proxy pass to ",(0,a.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:7777/"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:7778/"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"http://127.0.0.1:7779/")," I am using the container names ",(0,a.kt)("inlineCode",{parentName:"p"},"http://wiki_en:8888"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"http://wiki_fr:8888"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"http://wiki_de:8888"),".")),(0,a.kt)("p",null,"The root directories are left as they were:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"/opt/wiki/wiki-en/public\n/opt/wiki/wiki-fr/public\n/opt/wiki/wiki-de/public\n")),(0,a.kt)("p",null,"But now they are pointing inside the NGINX container and have to be mounted in from my host system. And I now need to expose the port 80 for the NGINX service:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yml"},"version: '3.8'\nservices:\n  wiki_en:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_en\n    networks:\n      - gateway\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-en/public:/wiki/public\n\n  wiki_fr:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_fr\n    networks:\n      - gateway\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-fr/public:/wiki/public\n\n  wiki_de:\n    image: my.gitlab.com:12345/wiki/wiki_container:latest\n    container_name: wiki_de\n    networks:\n      - gateway\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/wiki-de/public:/wiki/public\n\n  ingress:\n    image: nginx:stable-alpine\n    container_name: ingress\n    networks:\n      - gateway\n    ports:\n      - '80:80'\n    restart: unless-stopped\n    volumes:\n      - /opt/wiki/docker_ingress:/etc/nginx/conf.d\n      - /opt/wiki/wiki-en:/opt/wiki/wiki-en\n      - /opt/wiki/wiki-fr:/opt/wiki/wiki-fr\n      - /opt/wiki/wiki-de:/opt/wiki/wiki-de\n\nnetworks:\n  gateway: {}\n")))}c.isMDXComponent=!0},42874:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-b57dcf7a42ddd712383aadde6d3ef4c8.jpg"}}]);