"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[2828],{3905:(n,t,e)=>{e.d(t,{Zo:()=>p,kt:()=>d});var r=e(67294);function a(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function i(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,r)}return e}function s(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?i(Object(e),!0).forEach((function(t){a(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function l(n,t){if(null==n)return{};var e,r,a=function(n,t){if(null==n)return{};var e,r,a={},i=Object.keys(n);for(r=0;r<i.length;r++)e=i[r],t.indexOf(e)>=0||(a[e]=n[e]);return a}(n,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)e=i[r],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(a[e]=n[e])}return a}var o=r.createContext({}),g=function(n){var t=r.useContext(o),e=t;return n&&(e="function"==typeof n?n(t):s(s({},t),n)),e},p=function(n){var t=g(n.components);return r.createElement(o.Provider,{value:t},n.children)},u={inlineCode:"code",wrapper:function(n){var t=n.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(n,t){var e=n.components,a=n.mdxType,i=n.originalType,o=n.parentName,p=l(n,["components","mdxType","originalType","parentName"]),m=g(e),d=a,c=m["".concat(o,".").concat(d)]||m[d]||u[d]||i;return e?r.createElement(c,s(s({ref:t},p),{},{components:e})):r.createElement(c,s({ref:t},p))}));function d(n,t){var e=arguments,a=t&&t.mdxType;if("string"==typeof n||a){var i=e.length,s=new Array(i);s[0]=m;var l={};for(var o in t)hasOwnProperty.call(t,o)&&(l[o]=t[o]);l.originalType=n,l.mdxType="string"==typeof n?n:a,s[1]=l;for(var g=2;g<i;g++)s[g]=e[g];return r.createElement.apply(null,s)}return r.createElement.apply(null,e)}m.displayName="MDXCreateElement"},79682:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>g});var r=e(87462),a=(e(67294),e(3905));const i={sidebar_position:9070,slug:"2021-09-11",title:"Golang Refresher :: fmt & strings",authors:"mpolinowski",tags:["Go"]},s=void 0,l={unversionedId:"Development/Go/2021-09-11--golang-refresher-fmt-strings/index",id:"Development/Go/2021-09-11--golang-refresher-fmt-strings/index",title:"Golang Refresher :: fmt & strings",description:"Guangzhou, China",source:"@site/docs/Development/Go/2021-09-11--golang-refresher-fmt-strings/index.md",sourceDirName:"Development/Go/2021-09-11--golang-refresher-fmt-strings",slug:"/Development/Go/2021-09-11--golang-refresher-fmt-strings/2021-09-11",permalink:"/docs/Development/Go/2021-09-11--golang-refresher-fmt-strings/2021-09-11",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Development/Go/2021-09-11--golang-refresher-fmt-strings/index.md",tags:[{label:"Go",permalink:"/docs/tags/go"}],version:"current",sidebarPosition:9070,frontMatter:{sidebar_position:9070,slug:"2021-09-11",title:"Golang Refresher :: fmt & strings",authors:"mpolinowski",tags:["Go"]},sidebar:"tutorialSidebar",previous:{title:"Golang Refresher :: math & os",permalink:"/docs/Development/Go/2021-09-11--golang-refresher-math-os/2021-09-11"},next:{title:"Go Websockets",permalink:"/docs/Development/Go/2021-09-10--go-websockets/2021-09-10"}},o={},g=[{value:"Environment",id:"environment",level:2},{value:"Visual Studio Code",id:"visual-studio-code",level:3},{value:"The Go Standard Library",id:"the-go-standard-library",level:2},{value:"fmt :: String formatting and Printing",id:"fmt--string-formatting-and-printing",level:3},{value:"Print and Println",id:"print-and-println",level:4},{value:"Printf and Sprintf",id:"printf-and-sprintf",level:4},{value:"Stdin",id:"stdin",level:4},{value:"strings|strconv|unicode :: Manipulating string and text content",id:"stringsstrconvunicode--manipulating-string-and-text-content",level:3},{value:"strings - Basics",id:"strings---basics",level:4},{value:"strings - Search",id:"strings---search",level:4},{value:"strings - Manipulations",id:"strings---manipulations",level:4},{value:"strings - Mapping",id:"strings---mapping",level:4},{value:"strings - Builder",id:"strings---builder",level:4},{value:"strconv - Parse",id:"strconv---parse",level:4},{value:"unicode",id:"unicode",level:4}],p={toc:g};function u(n){let{components:t,...i}=n;return(0,a.kt)("wrapper",(0,r.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Guangzhou, China",src:e(42627).Z,width:"1500",height:"560"})),(0,a.kt)("h2",{id:"environment"},"Environment"),(0,a.kt)("h3",{id:"visual-studio-code"},"Visual Studio Code"),(0,a.kt)("p",null,"Install the Go extension und use the VS Code command line (F1) to ",(0,a.kt)("inlineCode",{parentName:"p"},"go: install/update tools")," and install everything that is offered: "),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Go Websockets",src:e(99576).Z,width:"1245",height:"363"})),(0,a.kt)("h2",{id:"the-go-standard-library"},"The Go Standard Library"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Part I"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/Development/Go/2021-09-11--golang-refresher-math-os/2021-09-11"},"Part II")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/Development/Go/2021-09-11--golang-refresher-network/2021-09-11"},"Part III"))),(0,a.kt)("h3",{id:"fmt--string-formatting-and-printing"},"fmt :: String formatting and Printing"),(0,a.kt)("p",null,"The ",(0,a.kt)("a",{parentName:"p",href:"https://pkg.go.dev/fmt@go1.17.1"},"fmt Package")," implements formatted I/O with functions analogous to C's printf and scanf. The format 'verbs' are derived from C's but are simpler."),(0,a.kt)("h4",{id:"print-and-println"},"Print and Println"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n\n    // Print a string\n    fmt.Print("a string")\n\n    // Print a string with newline\n    fmt.Println("a string followed by a newline")\n\n    // Print string with values\n    const fortytwo = 42\n    const answer = "answer"\n    const everything = "everything"\n    fmt.Println("The", answer, "to", everything, "is", fortytwo)\n\n    // Print a slice\n    items := []int{33, 66, 99, 666}\n    length, err := fmt.Println(items)\n    fmt.Println(length, err)\n\n}\n')),(0,a.kt)("p",null,"Run the file with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run ./main.go\n\na stringa string followed by a newline\nThe answer to everything is 42\n[33 66 99 666]\n15 <nil>\n")),(0,a.kt)("h4",{id:"printf-and-sprintf"},"Printf and Sprintf"),(0,a.kt)("p",null,"Print data with the help of ",(0,a.kt)("a",{parentName:"p",href:"https://pkg.go.dev/fmt@go1.17.1#hdr-Printing"},"formatting verbs")," - e.g. :"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"General:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%v"),(0,a.kt)("td",{parentName:"tr",align:null},"the value in a default format. ",(0,a.kt)("em",{parentName:"td"},"when printing structs, the plus flag (%+v) adds field names"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%#v"),(0,a.kt)("td",{parentName:"tr",align:null},"a Go-syntax representation of the value")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%T"),(0,a.kt)("td",{parentName:"tr",align:null},"a Go-syntax representation of the type of the value")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%%"),(0,a.kt)("td",{parentName:"tr",align:null},"a literal percent sign; consumes no value")))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Boolean:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%t"),(0,a.kt)("td",{parentName:"tr",align:null},"the word true or false")))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Integer:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%b"),(0,a.kt)("td",{parentName:"tr",align:null},"base 2")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%c"),(0,a.kt)("td",{parentName:"tr",align:null},"the character represented by the corresponding Unicode code point")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%d"),(0,a.kt)("td",{parentName:"tr",align:null},"base 10")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%o"),(0,a.kt)("td",{parentName:"tr",align:null},"base 8")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%O"),(0,a.kt)("td",{parentName:"tr",align:null},"base 8 with 0o prefix")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%q"),(0,a.kt)("td",{parentName:"tr",align:null},"a single-quoted character literal safely escaped with Go syntax.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%x"),(0,a.kt)("td",{parentName:"tr",align:null},"base 16, with lower-case letters for a-f")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%X"),(0,a.kt)("td",{parentName:"tr",align:null},"base 16, with upper-case letters for A-F")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%U"),(0,a.kt)("td",{parentName:"tr",align:null},'Unicode format: U+1234; same as "U+%04X"')))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Floating-point and complex constituents:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%b"),(0,a.kt)("td",{parentName:"tr",align:null},"decimalless scientific notation with exponent a power of two, in the manner of strconv.FormatFloat with the 'b' format, e.g. -123456p-78")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%e"),(0,a.kt)("td",{parentName:"tr",align:null},"scientific notation, e.g. -1.234456e+78")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%E"),(0,a.kt)("td",{parentName:"tr",align:null},"scientific notation, e.g. -1.234456E+78")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%f"),(0,a.kt)("td",{parentName:"tr",align:null},"decimal point but no exponent, e.g. 123.456")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%F"),(0,a.kt)("td",{parentName:"tr",align:null},"synonym for %f")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%g"),(0,a.kt)("td",{parentName:"tr",align:null},"%e for large exponents, %f otherwise. Precision is discussed below.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%G"),(0,a.kt)("td",{parentName:"tr",align:null},"%E for large exponents, %F otherwise")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%x"),(0,a.kt)("td",{parentName:"tr",align:null},"hexadecimal notation (with decimal power of two exponent), e.g. -0x1.23abcp+20")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%X"),(0,a.kt)("td",{parentName:"tr",align:null},"upper-case hexadecimal notation, e.g. -0X1.23ABCP+20")))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"String and slice of bytes (treated equivalently with these verbs):"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%s"),(0,a.kt)("td",{parentName:"tr",align:null},"the uninterpreted bytes of the string or slice")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%q"),(0,a.kt)("td",{parentName:"tr",align:null},"a double-quoted string safely escaped with Go syntax")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%x"),(0,a.kt)("td",{parentName:"tr",align:null},"base 16, lower-case, two characters per byte")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%X"),(0,a.kt)("td",{parentName:"tr",align:null},"base 16, upper-case, two characters per byte")))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Slice:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%p"),(0,a.kt)("td",{parentName:"tr",align:null},"address of 0th element in base 16 notation, with leading 0x")))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Pointer:"),(0,a.kt)("th",{parentName:"tr",align:null}))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"%p"),(0,a.kt)("td",{parentName:"tr",align:null},"base 16 notation, with leading 0x")))),(0,a.kt)("p",null,"The %b, %d, %o, %x and %X verbs also work with pointers, formatting the value exactly as if it were an integer."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\ntype circle struct {\n    radius int\n    border int\n}\n\nfunc main() {\n\n    x := 26\n    f := 337.99\n\n    // Formatting\n    // decimal\n    fmt.Printf("%d\\n", x)\n    // hexadecimal\n    fmt.Printf("%x\\n", x)\n\n    // Booleans\n    fmt.Printf("%t\\n", x > 10)\n\n    // Floats\n    fmt.Printf("%f\\n", f)\n    fmt.Printf("%e\\n", f)\n\n    // Explicit argument indexes\n    fmt.Printf("%d %d\\n", 69, 119)\n    fmt.Printf("%[2]d %[1]d\\n", 69, 119)\n\n    // Explicit argument indexes with repeated values\n    fmt.Printf("%d %d %#[1]o %#[2]x\\n", 69, 119)\n\n    // Print in default format\n    c := circle {\n        radius: 456,\n        border: 2,\n    }\n\n    fmt.Printf("%v\\n", c)\n    fmt.Printf("%+v\\n", c)\n    fmt.Printf("%T\\n", c)\n\n    // Use SprintF to return value as string\n    s := fmt.Sprintf("%d %d", 69, 119)\n    fmt.Println(s)\n    fmt.Printf("%T\\n", s)\n\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run ./main.go\n\n26\n1a\ntrue\n337.990000\n3.379900e+02\n69 119\n119 69\n69 119 0105 0x77\n{456 2}\n{radius:456 border:2}\nmain.circle\n69 119\nstring\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n\n    f := 997.123\n\n    // Decimal precision (e.g. 2 decimal points)\n    fmt.Printf("%.2f\\n", f)\n\n    // Max width (e.g. 15 spaces) and default precision (this will just\n    // add empty spaces in front to make lists look pretty)\n    fmt.Printf("%15f\\n", f)\n\n    // Padding and precision\n    fmt.Printf("%15.2f\\n", f)\n\n    // Add a character in front, e.g. a `+`\n    fmt.Printf("%+15.3f\\n", f)\n\n    // Padding with zeros instead of empty spaces\n    fmt.Printf("%015.4f\\n", f)\n\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\formatting.go\n\n997.12\n     997.123000\n         997.12\n       +997.123\n0000000997.1230\n")),(0,a.kt)("h4",{id:"stdin"},"Stdin"),(0,a.kt)("p",null,"Reading and printing user inputs:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "bufio"\n    "fmt"\n    "os"\n)\n\nfunc main() {\n\n    reader := bufio.NewReader(os.Stdin)\n    s, _ := reader.ReadString(\'\\n\')\n    fmt.Println(s)\n    \n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\nhello world\nhello world\n")),(0,a.kt)("h3",{id:"stringsstrconvunicode--manipulating-string-and-text-content"},"strings|strconv|unicode :: Manipulating string and text content"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://pkg.go.dev/strings@go1.17.1"},"Package strings")," implements simple functions to manipulate UTF-8 encoded strings."),(0,a.kt)("h4",{id:"strings---basics"},"strings - Basics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc main() {\n\n    s:= "This string is never gonna give you up, never gonna let you down..."\n\n    // Print length of a string\n    fmt.Println(len(s))\n\n    // Iteration\n    for _, ch := range s {\n        fmt.Print(string(ch), "-")\n    }\n    fmt.Println()\n\n    // Operators\n    fmt.Println("Sapporro" < "Asahi")\n    fmt.Println("Tomcat" > "Hornet")\n    fmt.Println("rick" == "Rick")\n    fmt.Println("rick" != "Rick")\n\n    // Compare\n    compare_01 := strings.Compare("Sapporro", "Asahi")\n    fmt.Println(compare_01)\n    compare_02 := strings.Compare("Sapporro", "Sapporro")\n    fmt.Println(compare_02)\n\n    // Unicode case-folding\n    fmt.Println(strings.EqualFold("\u4e2d\u570b", "\u53f0\u7063"))\n    fmt.Println(strings.EqualFold("\u53f0\u7063", "\u53f0\u7063"))\n\n    // Character cases\n    s1 := strings.ToUpper(s)\n    s2 := strings.ToLower(s)\n    s3 := strings.Title(s)\n    fmt.Println(s1, s2, s3)\n\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\n\n67\nT-h-i-s- -s-t-r-i-n-g- -i-s- -n-e-v-e-r- -g-o-n-n-a- -g-i-v-e- -y-o-u- -u-p-,- -n-e-v-e-r- -g-o-n-n-a- -l-e-t- -y-o-u- -d-o-w-n-.-.-.-       \nfalse\ntrue\nfalse\ntrue\n1\n0\nfalse\ntrue\nTHIS STRING IS NEVER GONNA GIVE YOU UP, NEVER GONNA LET YOU DOWN... this string is never gonna give you up, never gonna let you down... This \nString Is Never Gonna Give You Up, Never Gonna Let You Down...\n")),(0,a.kt)("h4",{id:"strings---search"},"strings - Search"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc main() {\n\n    s:= "This string is never gonna give you up, never gonna let you down..."\n    vowels := "aeiouAEIOU"\n\n    fname := "textfile.txt"\n    fname2 := "imagefile.png"\n\n    // Contains a sub-string\n    fmt.Println(strings.Contains(s, "gonna"))\n\n    // ContainsAny of these characters\n    fmt.Println(strings.ContainsAny(s, "xyzi"))\n\n    // Find offset of first instance of substring\n    fmt.Println(strings.Index(s, "give"))\n    fmt.Println(strings.Index(s, "rick"))\n\n    // Find offset of first instance of any of a set of characters\n    fmt.Println(strings.IndexAny(s, vowels))\n    fmt.Println(strings.IndexAny("xyzs", vowels))\n\n    // Check if strings starts/ends with a substring\n    fmt.Println(strings.HasSuffix(fname, "txt"))\n    fmt.Println(strings.HasPrefix(fname2, "image"))\n\n    // Count non-overlapping instances of a substring\n    fmt.Println(strings.Count(s, "gonna"))\n    fmt.Println(strings.Count(s, "is"))\n\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\ntrue\ntrue\n27\n-1\n2\n-1\ntrue\ntrue\n2\n2\n")),(0,a.kt)("h4",{id:"strings---manipulations"},"strings - Manipulations"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strings"\n    "unicode"\n)\n\nfunc main() {\n\n    s1 := "This string is never gonna give you up"\n    s2 := []string{"one", "two", "three", "four"}\n    s3 := "Never gonna give, never gonna give. Give you up!"\n\n    // Split into substrings\n    sub1 := strings.Split(s1, "never")\n    fmt.Printf("%q\\n", sub1)\n\n    // Split string around whitespaces\n    result := strings.Fields(s1)\n    fmt.Printf("%q\\n", result)\n\n    // Split around punctuation\n    f := func(c rune) bool {\n        return unicode.IsPunct(c)\n    }\n    result2 := strings.FieldsFunc(s3, f)\n    fmt.Printf("%q\\n", result2)\n\n    // Join substrings\n    result3 := strings.Join(s2, "-")\n    fmt.Println(result3)\n\n    // Replace substring\n    rep := strings.NewReplacer(",", " |", ".", " |", "!", " |")\n    result4 := rep.Replace(s3)\n    fmt.Println(result4)\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},'go run .\\main.go\n\n["This string is " " gonna give you up"]\n["This" "string" "is" "never" "gonna" "give" "you" "up"]\n["Never gonna give" " never gonna give" " Give you up"]\none-two-three-four\nNever gonna give | never gonna give | Give you up |\n')),(0,a.kt)("h4",{id:"strings---mapping"},"strings - Mapping"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    // Become a secret agent by encoding your messages\n    s:= \"This string is never gonna give you up, never gonna let you down...\"\n    // As a cypher push every character `+2`\n    shift := 2\n\n    // Mapping function\n    transform := func (r rune) rune {\n        switch {\n\n        // if character is uppercase\n        case r >= 'A' && r <= 'Z':\n            // get ASCII base code of character and add value of `shift`\n            value := int('A') + (int(r) - int('A') + shift)\n            // if you hit 91 (which equals 'Z')\n            if value > 91 {\n                // subtract 26 to start from the beginning 'A'\n                value -= 26\n            // if you hit the lower threshold\n            } else if value < 65 {\n                // add 26\n                value += 26\n            }\n            return rune(value)\n            \n        // if character is lowercase\n        case r >= 'a' && r <= 'z':\n            // get base code of character and add value of `shift`\n            value := int('a') + (int(r) - int('a') + shift)\n            // if you hit 91 (which equals 'z')\n            if value > 122 {\n                // subtract 26 to start from the beginning 'a'\n                value -= 26\n            // if you hit the lower threshold\n            } else if value < 97 {\n                // add 26\n                value += 26\n            }\n            return rune(value)\n        }\n        return r\n    }\n\n    // Encode message\n    encode := strings.Map(transform, s)\n    fmt.Println(encode)\n\n    // Encode message\n    shift = -shift\n    decode := strings.Map(transform, encode)\n    fmt.Println(decode)\n\n}\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\n\nVjku uvtkpi ku pgxgt iqppc ikxg aqw wr, pgxgt iqppc ngv aqw fqyp...\nThis string is never gonna give you up, never gonna let you down...\n")),(0,a.kt)("h4",{id:"strings---builder"},"strings - Builder"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strings"\n)\n\nfunc main() {\n    \n    var sb strings.Builder\n\n    // Provide content\n    sb.WriteString("This string is never gonna give you up \\n")\n    sb.WriteString("Never gonna let you down \\n")\n    sb.WriteString("Never gonna say goodbye \\n")\n    sb.WriteString("Never gonna tell a lie and hurt you \\n")\n\n    // Concatenate string\n    fmt.Println(sb.String())\n\n    // Get length of build string\n    fmt.Println("Builder size:", sb.Len())\n\n    // Builder capacity\n    fmt.Println("Capacity:", sb.Cap())\n\n    // Add capacity of 1k to reserve space\n    sb.Grow(1024)\n    fmt.Println("Capacity:", sb.Cap())\n\n    // Reset content of builder\n    sb.Reset()\n    fmt.Println("After reset")\n    fmt.Println("Capacity:", sb.Cap())\n    fmt.Println("Builder Size:", sb.Len())\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\nThis string is never gonna give you up \nNever gonna let you down\nNever gonna say goodbye\nNever gonna tell a lie and hurt you\n\nBuilder size: 128\nCapacity: 192\nCapacity: 1408\nAfter reset\nCapacity: 0\nBuilder Size: 0\n")),(0,a.kt)("h4",{id:"strconv---parse"},"strconv - Parse"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://pkg.go.dev/strconv@go1.17.1"},"Package strconv")," implements conversions to and from string representations of basic data types."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "strconv"\n)\n\nfunc main() {\n\n    str := "101"\n    num := 100\n\n\n    // Converting int into string\n    // The string function does NOT convert an int into a string!\n    newstr1 := string(str)\n    fmt.Println("The first string is:", newstr1)\n    fmt.Printf("%T\\n", newstr1)\n    newstr2 := string(num)\n    fmt.Println("This is not the string I expected:", newstr2)\n    fmt.Printf("%T\\n", newstr2)\n    // To transform the int use:\n    newstr3 := strconv.Itoa(num)\n    fmt.Println("The second string is:", newstr3)\n    fmt.Printf("%T\\n", newstr3)\n\n\n    // Convert string to int\n    newstr4, err := strconv.Atoi(str)\n    if (err != nil) {\n        fmt.Println(err.Error())\n    }\n    fmt.Println("This is now an integer:", newstr4)\n    fmt.Printf("%T\\n", newstr4)\n\n\n    // Parsing strings into different data types\n    b, _ := strconv.ParseBool("true")\n    fmt.Println(b)\n    fmt.Printf("%T\\n", b)\n    f, _ := strconv.ParseFloat("3.14159", 64)\n    fmt.Println(f)\n    fmt.Printf("%T\\n", f)\n    i, _ := strconv.ParseInt("-42", 10, 64)\n    fmt.Println(i)\n    fmt.Printf("%T\\n", i)\n    u, _ := strconv.ParseUint("42", 10, 64)\n    fmt.Println(u)\n    fmt.Printf("%T\\n", u)\n\n    // Format converts values into strings\n    s1 := strconv.FormatBool(true)\n    fmt.Println(s1)\n    fmt.Printf("%T\\n", s1)\n    s2 := strconv.FormatFloat(3.1415, \'E\', -1, 64)\n    fmt.Println(s2)\n    fmt.Printf("%T\\n", s2)\n    s3 := strconv.FormatInt(-42, 10)\n    fmt.Println(s3)\n    fmt.Printf("%T\\n", s3)\n    s4 := strconv.FormatUint(42, 10)\n    fmt.Println(s4)\n    fmt.Printf("%T\\n", s4)\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\n\nThe first string is: 101\nstring\nThis is not the string I expected: d\nstring\nThe second string is: 100\nstring\nThis is now an integer: 101\nint\ntrue\nbool\n3.14159\nfloat64\n-42\nint64\n42\nuint64\ntrue\nstring\n3.1415E+00\nstring\n-42\nstring\n42\nstring\n")),(0,a.kt)("h4",{id:"unicode"},"unicode"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://pkg.go.dev/unicode"},"Package unicode")," provides data and functions to test some properties of Unicode code points."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "unicode"\n)\n\nfunc main() {\n\n    const s = "This \'string\' is *never* gonna give you up, *never* gonna let you down..."\n\n    punctCount := 0\n    lowerCount, upperCount := 0, 0\n    spaceCount := 0\n    hexdigitCount :=0\n\n    // Count unicode characters:\n    for _, ch := range s {\n        if unicode.IsPunct(ch) {\n            punctCount++\n        }\n        if unicode.IsLower(ch) {\n            lowerCount++\n        }\n        if unicode.IsUpper(ch) {\n            upperCount++\n        }\n        if unicode.IsSpace(ch) {\n            spaceCount++\n        }\n        if unicode.Is(unicode.Hex_Digit, ch) {\n            hexdigitCount++\n        }\n    }\n\n    fmt.Println("Punctuations", punctCount)\n    fmt.Println("Lower Chars", lowerCount)\n    fmt.Println("Upper Chars", upperCount)\n    fmt.Println("Space Chars", spaceCount)\n    fmt.Println("HexDigital Chars", hexdigitCount)\n}\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run .\\main.go\n\nPunctuations 10\nLower Chars 50\nUpper Chars 1\nSpace Chars 12\nHexDigital Chars 9\n")))}u.isMDXComponent=!0},99576:(n,t,e)=>{e.d(t,{Z:()=>r});const r=e.p+"assets/images/GO_STD_LIB_01-79457b328b1ab5a3d4b018c439bddf5d.png"},42627:(n,t,e)=>{e.d(t,{Z:()=>r});const r=e.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-88971fd9c1b188353d6b4c2b974194a5.jpg"}}]);