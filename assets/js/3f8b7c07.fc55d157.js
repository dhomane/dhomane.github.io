"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[52314],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),m=c(n),d=a,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return n?r.createElement(h,o(o({ref:t},p),{},{components:n})):r.createElement(h,o({ref:t},p))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},47179:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const i={sidebar_position:6090,slug:"2022-07-21",title:"Rust - MQTT Hello World",authors:"mpolinowski",tags:["IoT"],image:"https://mpolinowski.github.io/img/search/mqtt.png",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references."},o=void 0,l={unversionedId:"IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/index",id:"IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/index",title:"Rust - MQTT Hello World",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references.",source:"@site/docs/IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/index.md",sourceDirName:"IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world",slug:"/IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/2022-07-21",permalink:"/docs/IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/2022-07-21",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/IoT-and-Machine-Learning/MQTT/2022-07-21-rust-hello-world/index.md",tags:[{label:"IoT",permalink:"/docs/tags/io-t"}],version:"current",sidebarPosition:6090,frontMatter:{sidebar_position:6090,slug:"2022-07-21",title:"Rust - MQTT Hello World",authors:"mpolinowski",tags:["IoT"],image:"https://mpolinowski.github.io/img/search/mqtt.png",description:"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references."},sidebar:"tutorialSidebar",previous:{title:"Go - MQTT Hello World",permalink:"/docs/IoT-and-Machine-Learning/MQTT/2022-07-22-go-hello-world/2022-07-22"},next:{title:"INSTAR MQTTv5 with Python - Client Connection",permalink:"/docs/IoT-and-Machine-Learning/MQTT/2022-06-23-instar-mqtt-python-part-I/2022-06-23"}},s={},c=[{value:"Rust Up",id:"rust-up",level:2},{value:"Hello World",id:"hello-world",level:2},{value:"Rusty MQTT",id:"rusty-mqtt",level:2},{value:"Initialisation the Project",id:"initialisation-the-project",level:3},{value:"MQTT Subscription",id:"mqtt-subscription",level:3},{value:"MQTT Publication",id:"mqtt-publication",level:3},{value:"Compile Binary Files",id:"compile-binary-files",level:3}],p={toc:c};function u(e){let{components:t,...i}=e;return(0,a.kt)("wrapper",(0,r.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Guangzhou, China",src:n(33242).Z,width:"2385",height:"962"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#rust-up"},"Rust Up")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#hello-world"},"Hello World")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#rusty-mqtt"},"Rusty MQTT"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#initialisation-the-project"},"Initialisation the Project")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#mqtt-subscription"},"MQTT Subscription")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#mqtt-publication"},"MQTT Publication")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#compile-binary-files"},"Compile Binary Files"))))),(0,a.kt)("p",null,"Rust is a multi-paradigm programming language designed for performance and safety, especially safe concurrency. Rust is syntactically similar to C++, but can guarantee memory safety by using a borrow checker to validate references. Rust achieves memory safety without garbage collection, and reference counting is optional."),(0,a.kt)("h2",{id:"rust-up"},"Rust Up"),(0,a.kt)("p",null,"Install Rust using ",(0,a.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/tools/install"},"rustup"),". To download Rustup and install Rust, run the following in your terminal, then follow the on-screen instructions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n")),(0,a.kt)("p",null,"In the Rust development environment, all tools are installed to the ~/.cargo/bin directory, and this is where you will find the Rust toolchain, including ",(0,a.kt)("inlineCode",{parentName:"p"},"rustc"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"cargo"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"rustup"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rustc --version\nrustc 1.63.0 (4b91a6ea7 2022-08-08)\n")),(0,a.kt)("p",null,"You can update your installation by running:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rustup update\nstable-x86_64-unknown-linux-gnu unchanged - rustc 1.63.0 (4b91a6ea7 2022-08-08)\n")),(0,a.kt)("p",null,"If at any point you would like to uninstall Rust, you can run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rustup self uninstall\n")),(0,a.kt)("h2",{id:"hello-world"},"Hello World"),(0,a.kt)("p",null,"This is the source code of the traditional Hello World program."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"hello.rs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'// This is the main function\nfn main() {\n    // Statements here are executed when the compiled binary is called\n\n    // Print text to the console\n    println!("Hello World!");\n}\n')),(0,a.kt)("p",null,"A binary can be generated using the Rust compiler ",(0,a.kt)("inlineCode",{parentName:"p"},"rustc"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"rustc hello.rs\n")),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"rustc")," will produce a hello binary that can be executed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"./hello\nHello World!\n")),(0,a.kt)("h2",{id:"rusty-mqtt"},"Rusty MQTT"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},(0,a.kt)("strong",{parentName:"p"},"FAIL"),": I don't know how to add a user login and the connection to my broker fails. The ",(0,a.kt)("a",{parentName:"p",href:"https://docs.rs/paho-mqtt/latest/paho_mqtt/create_options/struct.CreateOptionsBuilder.html#method.user_data"},"official documentation")," does not mention username/password \xaf","\\",(0,a.kt)("em",{parentName:"p"},"(\u30c4)"),"/\xaf  I will try ",(0,a.kt)("a",{parentName:"p",href:"/docs/IoT-and-Machine-Learning/MQTT/2022-07-22-go-hello-world/2022-07-22"},"using Go instead"),".")),(0,a.kt)("p",null,"Now I want to use the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/eclipse/paho.mqtt.rust.git"},"paho-mqtt client library")," in a Rust project, and implement ",(0,a.kt)("inlineCode",{parentName:"p"},"connect"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"subscribe"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"messaging")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"unsubscribe"),", etc., between the client and MQTT broker."),(0,a.kt)("h3",{id:"initialisation-the-project"},"Initialisation the Project"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"paho-mqtt")," is the most versatile and widely used MQTT client in the current Rust. The current ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/eclipse/paho.mqtt.rust/releases/tag/v0.11.1"},"latest version 0.11.1")," supports MQTT v5, 3.1.1, 3.1, and also supports data transfer via standard TCP, SSL / TLS, WebSockets, and QoS support 0, 1, 2, etc:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cargo new mqtt-example\ncd mqtt-example\nnano Cargo.toml\n")),(0,a.kt)("p",null,"Edit the Cargo.toml file in the project, and add the address of the ",(0,a.kt)("inlineCode",{parentName:"p"},"paho-mqtt")," library to the dependencies and specify the binary file corresponding to the subscribe, publish code file:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-toml"},'[package]\nname = "mqtt-example"\nversion = "0.1.0"\nedition = "2021"\n\n# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html\n\n[dependencies]\npaho-mqtt = { git = "https://github.com/eclipse/paho.mqtt.rust.git", branch = "master" }\n\n[[bin]]\nname = "sub"\npath = "src/sub/main.rs"\n\n[[bin]]\nname = "pub"\npath = "src/pub/main.rs"\n')),(0,a.kt)("h3",{id:"mqtt-subscription"},"MQTT Subscription"),(0,a.kt)("p",null,"I am going to use an ",(0,a.kt)("a",{parentName:"p",href:"https://wiki.instar.com/en/Advanced_User/INSTAR_MQTT_Broker/"},"INSTAR MQTT Camera")," as my MQTTv5 Broker:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Broker IP"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"192.168.2.115")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"MQTT Service Port"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"1883")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Broker Login"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"admin/instar"))),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Rust - MQTT Hello World",src:n(2255).Z,width:"1031",height:"693"})),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"src/sub/main.rs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::{\n    env,\n    process,\n    thread,\n    time::Duration\n};\n\nextern crate paho_mqtt as mqtt;\n\nconst DFLT_BROKER:&str = "tcp://192.168.2.115:1883";\nconst DFLT_CLIENT:&str = "rust_subscribe";\nconst DFLT_TOPICS:&[&str] = &["rust/mqtt", "rust/test"];\n// The qos list that match topics above.\nconst DFLT_QOS:&[i32] = &[0, 1];\n\n// Reconnect to the broker when connection is lost.\nfn try_reconnect(cli: &mqtt::Client) -> bool\n{\n    println!("Connection lost. Waiting to retry connection");\n    for _ in 0..12 {\n        thread::sleep(Duration::from_millis(5000));\n        if cli.reconnect().is_ok() {\n            println!("Successfully reconnected");\n            return true;\n        }\n    }\n    println!("Unable to reconnect after several attempts.");\n    false\n}\n\n// Subscribes to multiple topics.\nfn subscribe_topics(cli: &mqtt::Client) {\n    if let Err(e) = cli.subscribe_many(DFLT_TOPICS, DFLT_QOS) {\n        println!("Error subscribes topics: {:?}", e);\n        process::exit(1);\n    }\n}\n\nfn main() {\n    let host = env::args().nth(1).unwrap_or_else(||\n        DFLT_BROKER.to_string()\n    );\n\n    // Define the set of options for the create.\n    // Use an ID for a persistent session.\n    let create_opts = mqtt::CreateOptionsBuilder::new()\n        .server_uri(host)\n        .client_id(DFLT_CLIENT.to_string())\n        .finalize();\n\n    // Create a client.\n    let mut cli = mqtt::Client::new(create_opts).unwrap_or_else(|err| {\n        println!("Error creating the client: {:?}", err);\n        process::exit(1);\n    });\n\n    // Initialize the consumer before connecting.\n    let rx = cli.start_consuming();\n\n    // Define the set of options for the connection.\n    let lwt = mqtt::MessageBuilder::new()\n        .topic("test")\n        .payload("Consumer lost connection")\n        .finalize();\n    let conn_opts = mqtt::ConnectOptionsBuilder::new()\n        .keep_alive_interval(Duration::from_secs(20))\n        .clean_session(false)\n        .will_message(lwt)\n        .finalize();\n\n    // Connect and wait for it to complete or fail.\n    if let Err(e) = cli.connect(conn_opts) {\n        println!("Unable to connect:\\n\\t{:?}", e);\n        process::exit(1);\n    }\n\n    // Subscribe topics.\n    subscribe_topics(&cli);\n\n    println!("Processing requests...");\n    for msg in rx.iter() {\n        if let Some(msg) = msg {\n            println!("{}", msg);\n        }\n        else if !cli.is_connected() {\n            if try_reconnect(&cli) {\n                println!("Resubscribe topics...");\n                subscribe_topics(&cli);\n            } else {\n                break;\n            }\n        }\n    }\n\n    // If still connected, then disconnect now.\n    if cli.is_connected() {\n        println!("Disconnecting");\n        cli.unsubscribe_many(DFLT_TOPICS).unwrap();\n        cli.disconnect(None).unwrap();\n    }\n    println!("Exiting");\n}\n\n')),(0,a.kt)("h3",{id:"mqtt-publication"},"MQTT Publication"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"src/pub/main.rs")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'use std::{\n    env,\n    process,\n    time::Duration\n};\n\nextern crate paho_mqtt as mqtt;\n\nconst DFLT_BROKER:&str = "tcp://192.168.2.115:1883";\nconst DFLT_CLIENT:&str = "rust_publish";\nconst DFLT_TOPICS:&[&str] = &["rust/mqtt", "rust/test"];\n// Define the qos.\nconst QOS:i32 = 1;\n\nfn main() {\n    let host = env::args().nth(1).unwrap_or_else(||\n        DFLT_BROKER.to_string()\n    );\n\n    // Define the set of options for the create.\n    // Use an ID for a persistent session.\n    let create_opts = mqtt::CreateOptionsBuilder::new()\n        .server_uri(host)\n        .client_id(DFLT_CLIENT.to_string())\n        .finalize();\n\n    // Create a client.\n    let cli = mqtt::Client::new(create_opts).unwrap_or_else(|err| {\n        println!("Error creating the client: {:?}", err);\n        process::exit(1);\n    });\n\n    // Define the set of options for the connection.\n    let conn_opts = mqtt::ConnectOptionsBuilder::new()\n        .keep_alive_interval(Duration::from_secs(20))\n        .clean_session(true)\n        .finalize();\n\n    // Connect and wait for it to complete or fail.\n    if let Err(e) = cli.connect(conn_opts) {\n        println!("Unable to connect:\\n\\t{:?}", e);\n        process::exit(1);\n    }\n\n    // Create a message and publish it.\n    // Publish message to \'test\' and \'hello\' topics.\n    for num in 0..5 {\n        let content =  "Hello world! ".to_string() + &num.to_string();\n        let mut msg = mqtt::Message::new(DFLT_TOPICS[0], content.clone(), QOS);\n        if num % 2 == 0 {\n            println!("Publishing messages on the {:?} topic", DFLT_TOPICS[1]);\n            msg = mqtt::Message::new(DFLT_TOPICS[1], content.clone(), QOS);\n        } else {\n            println!("Publishing messages on the {:?} topic", DFLT_TOPICS[0]);\n        }\n        let tok = cli.publish(msg);\n\n                if let Err(e) = tok {\n                        println!("Error sending message: {:?}", e);\n                        break;\n                }\n    }\n\n\n    // Disconnect from the broker.\n    let tok = cli.disconnect(None);\n    println!("Disconnect from the broker");\n    tok.unwrap();\n}\n')),(0,a.kt)("h3",{id:"compile-binary-files"},"Compile Binary Files"),(0,a.kt)("p",null,"The following command generates the sub, pub binary file in the mqtt-example/target/debug directory:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"cargo build\n    Finished dev [unoptimized + debuginfo] target(s) in 0.07s\n")),(0,a.kt)("p",null,"Execute the sub binary file and wait for the message to be published."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"./sub\nUnable to connect:\n        Paho(-1)\n")),(0,a.kt)("p",null,"Executing the pub binary file, you can see that messages have been published to the topics rust/test and rust/mqtt, respectively."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"./pub\nUnable to connect:\n        Paho(-1)\n")))}u.isMDXComponent=!0},2255:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/Rust_MQTT_Hello_World_01-68435046037215dc6dc8ad7c87b5b34c.png"},33242:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-4dda98a4eb3b498839926e0b6a5039aa.jpg"}}]);