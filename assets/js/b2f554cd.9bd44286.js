"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[11477],{30010:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"typical_ci_process","metadata":{"permalink":"/blog/typical_ci_process","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-06-02-typical_ci_process/index.md","source":"@site/blog/2019-06-02-typical_ci_process/index.md","title":"GitLab CI/CD","description":"GitLab CI/CD","date":"2019-06-02T00:00:00.000Z","formattedDate":"June 2, 2019","tags":[{"label":"DevOps","permalink":"/blog/tags/dev-ops"}],"readingTime":8.14,"hasTruncateMarker":true,"authors":[{"name":"Mike Polinowski","title":"CTO INSTAR Deutschland GmbH","url":"https://github.com/mpolinowski","imageURL":"https://github.com/mpolinowski.png","key":"mpolinowski"}],"frontMatter":{"slug":"typical_ci_process","title":"GitLab CI/CD","authors":["mpolinowski"],"tags":["DevOps"]},"nextItem":{"title":"What is meant by CI/CD?","permalink":"/blog/continuous-integration"}},"content":"## GitLab CI/CD\\n\\nGitLab CI/CD is a tool built into GitLab for software development through the continuous methodologies:\\n\\n* Continuous Integration (CI)\\n* Continuous Delivery (CD)\\n* Continuous Deployment (CD)\\n\\n__Note__: Out-of-the-box management systems can decrease hours spent on maintaining toolchains by 10% or more. Watch our \u201cMastering continuous software development\u201d webcast to learn about continuous methods and how GitLab\u2019s built-in CI can help you simplify and scale software development.\\n\\n\x3c!--truncate--\x3e\\n\\n\x3c!-- TOC --\x3e\\n\\n- [GitLab CI/CD](#gitlab-cicd)\\n- [Overview](#overview)\\n- [Getting started](#getting-started)\\n- [Migrating from CircleCI](#migrating-from-circleci)\\n- [Concepts](#concepts)\\n- [Configuration](#configuration)\\n- [Feature set](#feature-set)\\n- [Code repository](#code-repository)\\n- [Static analysis](#static-analysis)\\n- [Gradle build script with Findbugs and Checkstyle](#gradle-build-script-with-findbugs-and-checkstyle)\\n- [$ gradle check](#-gradle-check)\\n- [Packaging and deployment to the test/staging environment](#packaging-and-deployment-to-the-teststaging-environment)\\n\\n\x3c!-- /TOC --\x3e\\n\\n\\n## Overview\\n\\nContinuous Integration works by pushing small code chunks to your application\u2019s code base hosted in a Git repository, and, to every push, run a pipeline of scripts to build, test, and validate the code changes before merging them into the main branch.\\n\\nContinuous Delivery and Deployment consist of a step further CI, deploying your application to production at every push to the default branch of the repository.\\n\\nThese methodologies allow you to catch bugs and errors early in the development cycle, ensuring that all the code deployed to production complies with the code standards you established for your app.\\n\\nFor a complete overview of these methodologies and GitLab CI/CD, read the Introduction to CI/CD with GitLab.\\n\\n\\n## Getting started\\n\\nGitLab CI/CD is configured by a file called .gitlab-ci.yml placed at the repository\u2019s root. This file creates a pipeline, which runs for changes to the code in the repository. Pipelines consist of one or more stages that run in order and can each contain one or more jobs that run in parallel. These jobs (or scripts) get executed by the GitLab Runner agent.\\n\\nTo get started with GitLab CI/CD, we recommend you read through the following documents:\\n\\n* How GitLab CI/CD works.\\n* Fundamental pipeline architectures.\\n* GitLab CI/CD basic workflow.\\n* Step-by-step guide for writing .gitlab-ci.yml for the first time.\\n\\nIf you\u2019re migrating from another CI/CD tool, check out our handy references:\\n\\n## Migrating from CircleCI\\n\\nMigrating from Jenkins\\nYou can also get started by using one of the .gitlab-ci.yml templates available through the UI. You can use them by creating a new file, choosing a template that suits your application, and adjusting it to your needs:\\n\\n![Gitlab CI](./gitlab-ci-yml.png)\\n\\n\\n## Concepts\\n\\nGitLab CI/CD uses a number of concepts to describe and run your build and deploy.\\n\\n|Concept|Description|\\n|---|---|\\n|Pipelines|Structure your CI/CD process through pipelines.|\\n|Environment variables|Reuse values based on a variable/value key pair.|\\n|Environments|Deploy your application to different environments (e.g., staging, production).|\\n|Job artifacts|Output, use, and reuse job artifacts.|\\n|Cache dependencies|Cache your dependencies for a faster execution.|\\n|GitLab Runner|Configure your own runners to execute your scripts.|\\n|Pipeline efficiency|Configure your pipelines to run quickly and effienctly.|\\n\\n\\n## Configuration\\n\\nGitLab CI/CD supports numerous configuration options:\\n\\n|Configuration|Description|\\n|---|---|\\n|Schedule pipelines|Schedule pipelines to run as often as you need.|\\n|Custom path for .gitlab-ci.yml|Define a custom path for the CI/CD configuration file.|\\n|Git submodules for CI/CD|Configure jobs for using Git submodules.|\\n|SSH keys for CI/CD|Using SSH keys in your CI pipelines.|\\n|Pipeline triggers|Trigger pipelines through the API.|\\n|Pipelines for Merge Requests|Design a pipeline structure for running a pipeline in merge requests.|\\n|Integrate with Kubernetes clusters|Connect your project to Google Kubernetes Engine (GKE) or an existing Kubernetes cluster.|\\n|Optimize GitLab and GitLab Runner for large repositories|Recommended strategies for handling large repositories.|\\n|.gitlab-ci.yml full reference|All the attributes you can use with GitLab CI/CD.|\\n\\n\\nNote that certain operations can only be performed according to the user and job permissions.\\n\\n\\n## Feature set\\n\\nUse the vast GitLab CI/CD to easily configure it for specific purposes. Its feature set is listed on the table below according to DevOps stages.\\n\\n\\n|Feature|Description|\\n|---|---|\\n|Configure| |\\n|Auto DevOps|Set up your app\u2019s entire lifecycle.|\\n|ChatOps|Trigger CI jobs from chat, with results sent back to the channel.|\\n|Verify| |\\n|Browser Performance Testing|Quickly determine the browser performance impact of pending code changes.|\\n|Load Performance Testing|Quickly determine the server performance impact of pending code changes.|\\n|CI services|Link Docker containers with your base image.|\\n|Code Quality|Analyze your source code quality.|\\n|GitLab CI/CD for external repositories |Get the benefits of GitLab CI/CD combined with repositories in GitHub and Bitbucket Cloud.|\\n|Interactive Web Terminals |Open an interactive web terminal to debug the running jobs.|\\n|Unit test reports|Identify script failures directly on merge requests.|\\n|Using Docker images|Use GitLab and GitLab Runner with Docker to build and test applications.|\\n|Release| |\\n|Auto Deploy|Deploy your application to a production environment in a Kubernetes cluster.|\\n|Building Docker images|Maintain Docker-based projects using GitLab CI/CD.|\\n|Canary Deployments |Ship features to only a portion of your pods and let a percentage of your user base to visit the temporarily deployed feature.|\\n|Deploy Boards |Check the current health and status of each CI/CD environment running on Kubernetes.|\\n|Feature Flags |Deploy your features behind Feature Flags.|\\n|GitLab Pages|Deploy static websites.|\\n|GitLab Releases|Add release notes to Git tags.|\\n|Review Apps|Configure GitLab CI/CD to preview code changes.|\\n|Cloud deployment|Deploy your application to a main cloud provider.|\\n|Secure| |\\n|Container Scanning |Check your Docker containers for known vulnerabilities.|\\n|Dependency Scanning |Analyze your dependencies for known vulnerabilities.|\\n|License Compliance |Search your project dependencies for their licenses.|\\n|Security Test reports |Check for app vulnerabilities.|\\n\\n\\n\\n\\n\\n#####################\\n\\nContinuous Integration (CI) is a phase in the software development cycle where code from different team members or different features are integrated together. This usually involves merging code (integration), building the application and carrying out basic tests all within an ephemeral environment.\\n\\nIn the past, the code was integrated at an \u201cintegration phase\u201d of the software development life cycle. This phase came after different teams would have spent weeks, months or even years working in separately, dedicated to different (parts of) application or services. You can guess how painful the integration phase of the project would have been. It was not uncommon to spend weeks or even months in this phase. This was during the waterfall era.\\n\\nWith Extreme Programming (XP) and agile, integration became frequent with developers integrating as often as possible usually soon after a unit is complete. This is done on the shared source code repository. The frequent integration became automated and continuous which prompted the need for some kind of checks before the new code is integrated. Thus, Continuous Integration.\\n\\n\\nCI workflows vary a lot depending on tools, programming language, project and many other factors but a common flow has these steps.\\n\\n* Pushing to the code repository\\n* Static analysis\\n* Pre-deployment testing\\n* Packaging and deployment to the test environment\\n* Post-deployment testing\\n\\nLet\u2019s take a look at how this flow would work on a java project with Gradle as the build tool.\\n\\n\\n## Code repository\\n\\nTypically, there would have a code repository and some kind of workflow for contributing new code. Depending on the workflow, committing code kicks off the CI pipeline, which often starts with static code analysis. You could refer to this post to help choose an appropriate workflow.\\n\\n\\n## Static analysis\\n\\nStatic (code) analysis is done on the code base of the application without the need to run the software. The goal here is to ensure the code doesn\u2019t have possible bugs and conforms to standard formatting and styling.\\n\\nLet\u2019s add FindBugs to check for possible errors and Checkstyle to ensure the project conforms to coding standard (we\u2019ll use the Google Java Style).\\n\\nThe Gradle build script would be something like this:\\n\\n\\n```\\napply plugin: \'java\'\\napply plugin: \'findbugs\'\\napply plugin: \'checkstyle\'\\n\\n\\nrepositories {\\n    mavenCentral()\\n}\\n\\ndependencies {\\n  ...\\n}\\n\\ntasks.withType(FindBugs) {\\n  reports {\\n    xml.enabled false\\n    html.enabled true\\n  }\\n}\\n\\ntasks.withType(Checkstyle) {\\n  reports {\\n    xml.enabled false\\n    html.enabled true\\n  }\\n}\\n```\\n\\n## Gradle build script with Findbugs and Checkstyle\\n\\nTo complete the Checkstyle configuration, we\u2019ll need to add a Checkstyle configuration file to the project path config/checkstyle/checkstyle.xml. There\u2019s a sample config file on GitHub based on the Google Java style. With FindBugs and Checkstyle configured, static analysis can now be run:\\n\\n## $ gradle check\\n\\nAt this phase, any test that could be run without deploying to a server should be. This will include unit tests and various other types of tests (maybe functional or integration). This phase is used to ensure that the change set doesn\u2019t break functionalities and works well with other parts code since the tests are run on the whole code base, not just the new changes (as the author might have done on the dev env).\\n\\n## Packaging and deployment to the test/staging environment\\n\\nDepending on the kind of project, the application is built, packaged, sent to a test or staging environment (that mimics production). This ensures that the integrated changes build well with other parts and can be deployed for a functional test can to be carried out. It\u2019s at this phase that we also verify that the new changes are compatible with other libraries and the deployment environment. This is phase should also automated.\\n\\nFor tests that need the application to be deployed, this phase of the CI pipeline is where they\u2019re run. The tests vary depending on tools, frameworks, and language of the application but they\u2019re usually functional integration and performance tests. Successful execution of this phase ends the CI pipeline for the changeset signalling it\u2019s good enough for users.\\n\\nOnce the CI pipeline completes successfully, the deployed application could undergo a manual test by a \u201cuser\u201d or the QA team to ensure that it fits the client\u2019s requirements. The packages or artifacts generated by the CI pipeline can now be taken/deployed to production. This can also be automated with a successful implementation of a Continuous Delivery (CD) pipeline.\\n\\nHope you find this useful. look forward to seeing how this is implemented for different projects."},{"id":"continuous-integration","metadata":{"permalink":"/blog/continuous-integration","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-06-01-continuous_integration_deployment/index.md","source":"@site/blog/2019-06-01-continuous_integration_deployment/index.md","title":"What is meant by CI/CD?","description":"What is meant by CI/CD?","date":"2019-06-01T00:00:00.000Z","formattedDate":"June 1, 2019","tags":[{"label":"DevOps","permalink":"/blog/tags/dev-ops"}],"readingTime":4.76,"hasTruncateMarker":true,"authors":[{"name":"Mike Polinowski","title":"CTO INSTAR Deutschland GmbH","url":"https://github.com/mpolinowski","imageURL":"https://github.com/mpolinowski.png","key":"mpolinowski"}],"frontMatter":{"slug":"continuous-integration","title":"What is meant by CI/CD?","authors":["mpolinowski"],"tags":["DevOps"]},"prevItem":{"title":"GitLab CI/CD","permalink":"/blog/typical_ci_process"},"nextItem":{"title":"Application Development and Server Operation","permalink":"/blog/devops-introduction"}},"content":"## What is meant by CI/CD?\\n\\nThis is a method of regularly delivering apps to customers and automating all phases of application development. The main concepts of CI/CD are Continuous Integration, Continuous Delivery and Continuous Deployment. CI/CD solves the problems that integrating new code can cause for DevOps teams (also known as \\"integration hell\\").\\n\\nIn particular, CI/CD ensures continuous automation and monitoring throughout the entire app lifecycle, from the integration and testing to the deployment and implementation phase. These interrelated practices are often referred to as the \\"CI/CD pipeline\\" and are supported by agile collaboration between DevOps teams.\\n\\n\x3c!--truncate--\x3e\\n\\n\x3c!-- TOC --\x3e\\n\\n- [What is meant by CI/CD?](#what-is-meant-by-cicd)\\n  - [What is the difference between CI and CD (and the other CD)?](#what-is-the-difference-between-ci-and-cd-and-the-other-cd)\\n- [CI/CD Pipeline](#cicd-pipeline)\\n- [Continuous Integration](#continuous-integration)\\n- [Technical Details](#technical-details)\\n  - [Continuous Delivery](#continuous-delivery)\\n  - [Continuous Deployment](#continuous-deployment)\\n\\n\x3c!-- /TOC --\x3e\\n\\n### What is the difference between CI and CD (and the other CD)?\\n\\nThe abbreviation CI/CD has different meanings. \\"CI\\" means Continuous Integration, i.e. the automation process for developers. In a successful CI, new code changes for apps are regularly developed, checked and merged in a common repository. This is intended to prevent the conflict that too many branches of an app can cause if they are developed simultaneously.\\n\\n\\"CD\\" means Continuous Delivery or Continuous Deployment. These are related concepts that are sometimes used synonymously. Although both concepts deal with the automation of further phases of the pipeline, the terms are sometimes used differently to illustrate the extent of automation.\\n\\nContinuous delivery typically means that a developer\'s app changes are automatically tested for bugs and uploaded to a repository (such as GitHub or a container registry) from where they can be deployed by the operations team in a live production environment. This process is the answer to transparency and communication problems between dev and business teams. It is designed to ensure that new code can be implemented with minimal effort.\\n\\nContinuous Deployment (the other \\"CD\\") can refer to the automatic release of developer changes from the repository to the production phase, where they can be used directly by the customer. This process is intended to counteract the overload of operations teams during manual processes that slow down application deployment. Continuous Development extends the benefits of continuous delivery by automating the next phase of the pipeline.\\n\\n\\n## CI/CD Pipeline\\n\\n![CI/CD Pipeline](./ci-cd-pipeline.png)\\n\\nSometimes CI/CD refers only to the interrelated practices of Continuous Integration and Continuous Delivery, but sometimes it also refers to all three concepts of Continuous Integration, Continuous Delivery and Continuous Deployment. The whole thing is further complicated by the fact that Continuous Delivery sometimes also refers to the processes of Continuous Deployment.\\n\\nUltimately, however, these details do not get us anywhere. Just think of CI/CD as a process that is often visualized as a pipeline and that involves a high degree of continuous automation and monitoring in application development. Depending on the case, the interpretation of the term depends on the degree of automation of the CI/CD pipeline. Many companies initially work with CI and later continue the process with automated deployment and implementation, e.g. for cloudnative apps.\\n\\n\\n## Continuous Integration\\n\\nIn modern application development, several developers work on different features of the same app. The simultaneous merging of all source code branches in one day (also known as \\"Merge Day\\") can be a huge amount of work and time. The reason for this is that application changes made by developers working separately can conflict with each other if they are performed simultaneously. This problem can be aggravated if each developer defines his own local Integrated Development Environment (IDE) instead of creating a common cloud-based IDE as a team.\\n\\nContinuous Integration (CI) allows developers to merge their code changes into a common \\"branch\\" or \\"trunk\\" of the application much more frequently, sometimes even daily. Once a developer\'s changes are merged, they are validated in automated app builds and different levels of automation testing (typically unit and integration testing). This ensures that functionality has not been compromised. All classes and functions up to the various modules of the app must be tested. If the automated test detects conflicts between current and new code, CI can help resolve them more quickly and frequently.\\n\\n\\n## Technical Details\\n\\n### Continuous Delivery\\n\\nAfter automating builds and unit and integration testing for the CI, continuous delivery also automatically releases the validated code to a repository. Therefore, to ensure an efficient continuous delivery process, the CI must already be integrated into your development pipeline. The goal of continuous delivery is a code base that can be made available in a production environment at any time.\\n\\nWith continuous delivery, every phase - from merging code changes to delivering production-ready builds - includes automated testing and code releases. At the end of this process, the operations team can quickly and easily deploy an app into production.\\n\\n\\n### Continuous Deployment\\n\\nThe final phase of the CI/CD pipeline is Continuous Deployment. As an extension of Continuous Delivery, in which production-ready builds are automatically released to a code repository, Continuous Deployment also automates the release of an app into the production phase. Because the production phase in the pipeline is not preceded by a manual gate, automated testing must always be well thought through in continuous deployment.\\n\\nIn practice, continuous deployment means that a developer\'s app changes can go live within minutes of their creation (provided they pass the automated test). This makes continuous integration of user feedback much easier. All these interrelated CI/CD practices make an application implementation less risky because changes are released in parts rather than all at once. However, the up-front investment is considerable, since automatic tests must be written for the various test and release phases in the CI/CD pipeline."},{"id":"devops-introduction","metadata":{"permalink":"/blog/devops-introduction","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-30-devops-introduction/index.md","source":"@site/blog/2019-05-30-devops-introduction/index.md","title":"Application Development and Server Operation","description":"I just want to build something useful","date":"2019-05-30T00:00:00.000Z","formattedDate":"May 30, 2019","tags":[{"label":"DevOps","permalink":"/blog/tags/dev-ops"}],"readingTime":8.57,"hasTruncateMarker":true,"authors":[{"name":"Mike Polinowski","title":"CTO INSTAR Deutschland GmbH","url":"https://github.com/mpolinowski","imageURL":"https://github.com/mpolinowski.png","key":"mpolinowski"}],"frontMatter":{"slug":"devops-introduction","title":"Application Development and Server Operation","authors":["mpolinowski"],"tags":["DevOps"]},"prevItem":{"title":"What is meant by CI/CD?","permalink":"/blog/continuous-integration"},"nextItem":{"title":"The Modern Web","permalink":"/blog/the-modern-web"}},"content":"## I just want to build something useful\\n\\nComing from a conservative country I was raised with a strong sensibility for the separation of concerns - put your inline CSS into a style sheet, let the computer scientist handle the shopping list for new office computers and never even think about putting the salt shaker into the spice rack! Salt belongs to MSG and sugar rack on the right.\\n\\nSo is DevOps really the monster it is made out to be? Is a backend developer able to design a usable user interface and will a frontend dev bring down the whole service by ignoring best practices of harding the server before uploading his application?\\n\\n> How does a Jack-of-all-Trades handle a specific task compared to a specialist?\\n\\n\x3c!--truncate--\x3e\\n\\n\\n\x3c!-- TOC --\x3e\\n\\n- [Application Development and Server Operation](#application-development-and-server-operation)\\n  - [I just want to build something useful](#i-just-want-to-build-something-useful)\\n    - [The Curse](#the-curse)\\n    - [The Cure](#the-cure)\\n    - [The Future](#the-future)\\n  - [So what do I really need to know?](#so-what-do-i-really-need-to-know)\\n    - [Server Security](#server-security)\\n    - [Server Monitoring](#server-monitoring)\\n    - [Continous Integration](#continous-integration)\\n    - [State Management](#state-management)\\n    - [Web Application](#web-application)\\n\\n\x3c!-- /TOC --\x3e\\n\\n\\n### The Curse\\n\\nWhen you start out as a backend server admin it can be frustrating to get started on your own. I was always the guy who did not dive into the details but wanted to learn skills that allowed me to build something. As a backend engineer this lead you down the road of setting up a webserver, maybe even a cluster of servers that exchange information through micro services. You might even add hardened military grade security so that not even that Nigerian prince, everyone is talking about, can hack his way into your Cloud Servers. Amazing! But what now?\\n\\nOr you start our at the frontend of things. You saw this beautiful website - all those smooth animations, beautiful colour palets and responsiveness. That is what you want to learn how to create yourself. And after months of hard work you figured out your stack, you put it all together and your page looks amazing! But what now?\\n\\nBackend and frontend belong together but they - literally - do not even speak the same language...\\n\\n\\n### The Cure\\n\\nWhen I started out there was still this divide and the internet was full of memes about sysadmins being unable to grasp the necessities of modern web applications - there must have been memes coming in from the backend as well... I just did not get the IRC invite.\\n\\nBut there was also a new shining light on the horizon:\\n\\n> Why don\'t you do it in Javascript?\\n\\nI fell in love with React frontends right away. Then learning that you can use a Node.js backend to drive your application - that sounded just like the solution I was looking for.\\n\\nThe first full-stack web application I ever wrote for my company was a Node.js/Express.js knowledge base. Just a bunch of EJS pages served by a Javascript backend. I never looked back to the old times since.\\n\\n\\n### The Future\\n\\nI have - so far - never worked on a web project that reached the limitations of a Javascript backend. I am aware that they are there. But breaking down my applications into small, single purpose services has prevented me from bumping into them.\\n\\nThere is one trend that is slowly creeping it\'s way into my work, though. The backend itself is slowly abstracted away from me. First I started to wrap my code into Containers - because that was convenient. And now I am supposed to com up with solutions to keep an eye on my swarm of little virtual minions. The big __K__ arrived. Written in the Go language and complex to the degree of a Google Megacorp server center. And all controllable by the magic word `kubectl`.\\n\\n\\n\\n## So what do I really need to know?\\n\\n### Server Security\\n\\nIn a true sysadmin fashion - let\'s start with fighting the dark minions of Mordor.\\n\\nI remember back in the days of Windows 95 - when I set up a new PC at my workplace and plugged it into the university network... It died. The network was so overloaded with virtual pathogens that you first had to find a way to update your Windows __offline__ to the newest version, add a firewall and a solid virus scanner. And then you could plug it into the network.\\n\\n> Welcome to the Internet\\n\\nSecuring your server is mandatory. Even if it is just your personal playground. It is valuable training to keep your system updated (which sometimes kills your application and has you hunt down insects in your code) and maintain a sensible degree of security:\\n\\n\\n* __Randomly generate a long SSH login__: There are ways to use those without memorizing them - so make them hard... so to speak.\\n* __Change your default ports__: When an evildoer decides to attack your server, it does not matter where you put your SSH port - she will find it. But most attacks that I witnessed were executed by bots. Those bots just rattle your cage and see if they can find a weakness. If they can\'t find one fast enough they move on. If they can\'t find your SSH port automatically, they don\'t bother to return.\\n* __A Mould with Crocodiles and a Wall of Fire__: Your server is your castle. Make sure that the only ports that are opened are the ones that your application needs to communicate with the world. Those entry point can be hardened against brute force and denial-of-service attacks.\\n* __Keep your Software Up2Date__: There are many reasons why your server still runs a system that is 5 years old and was never updated or restarted. Such servers are kept caged in inside your local network. Every server that communicates with the world is kept fresh.\\n\\n\\n### Server Monitoring\\n\\nWhen you have your first 1, 2 or 3 servers to maintain it is exciting! The first thing you do in the morning is to check all of them, run the commands to see that everything is still running and happy and check the log files for anomalies. Once you have more than 10 under your control you do not do that anymore. You need a server dashboard that gives you the all-green and you are good to go.\\n\\nI did try out a few Kubernetes based monitoring tools and they are fantastic. You get everything you need at a glance. And since it is Kubernetes you usually just see that there was an issue and it was fixed 20ms later.\\n\\nBut I consider myself lucky to have worked for companies that still maintained their own servers - things still had to be done by hand. Giving you an inside into what tools like Kubernetes present to you as a magic blackbox.\\n\\nThere isn\'t a shortage of tools that install agents on your server that report to a master dashboard. They can be configured to monitor your server hardware and web services. Making sure that everything is running smoothly.\\n\\n\\n\\n### Continous Integration\\n\\n> The time of major releases is over!\\n\\nThere is no longer a new Windows every 2 years - now it is Windows 10 and it stays that way. __Continous Integration__ (CI) means that you commit your edited source code today. It will be tested, automatically over night and be deployed before you return the next day - or if that sounds scary to you, there might be a blinking button waiting for you to start the deployment whenever you are ready.\\n\\nWhat do you need to achieve this? \\n\\n* A source control system that keeps track of your changes\\n* A tool that receives your source code and runs a build for you\\n* A testing suite that knows what the release should be able to do\\n* A containerized solution to swap in your new code without interrupting your service\\n\\n\\n### State Management\\n\\nJust like Server Management, State Management frees up your hands when you start to become overwhelmed with the amount of servers that you have to maintain. There will be the point where you are no longer able to be logged into every server, see drop-outs and react in second notice.\\n\\nAgain, Kubernetes handles most of that for you. But since we are dealing with a classical setup here - we do it ourself. State management tools are often configured by something like a YAML file (ever wondered where Kubernetes got all those ideas from?). And the state that is configured could be, e.g. install a webserver, copy a configuration file to the conf folder and some HTML content to the serve folder, when done run the server as a system service, if a new configuration file becomes available upload it to the server and restart the service, etc...\\n\\nState management often overlaps with CI/CD pipelines. Or it can be the __Continous Deployment__ (CD) part of that pipeline. The selection of tools available can be a bit overwhelming ~ similar to Server Management tools. But you will quickly find out that all of the do the same thing with different naming conventions and slightly different looking config files. Just make sure that the program you choose integrates well into the rest of your pipeline and that the rest of the team is comfortable with it.\\n\\n\\n### Web Application\\n\\nMost modern \\"website\\" is now applications. Gone are the days where all you needed to set up a site was HTML, CSS and maybe some jQuery for a fancy accordion animation inside your navigation menu.\\n\\nAn web application connects your user to databases, services that he can use e.g. to authenticate himself and delivers a rich interface that sometimes looks and behaves more like a desktop application than a website.\\n\\nHow to set up a web application broadly differs depending on what kind of services you want to provide. But the basic ingredients of every application are:\\n\\n* __Database__: To store your page data as well as data generated by user interactions\\n* __Webserver__: It doesn\'t matter if you prefer NGINX, Apache or Express.js, your interface needs to be served\\n* __Frontend__: If your backend speaks Javascript it makes sense to have flavour of JS in your frontend as well - React, Angular, Vue"},{"id":"the-modern-web","metadata":{"permalink":"/blog/the-modern-web","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2019-05-29-web-development/index.md","source":"@site/blog/2019-05-29-web-development/index.md","title":"The Modern Web","description":"When websites stopped being simple fixed HTML layouts with hyperlinks they called it Web 2.0. What number are we at now? I must have lost count. I have learnt HTML5 and CSS3 on my own long before I had to use it professionally. And once I started being asked to provide solutions for web projects... those no longer seemed to matter much. Sure JSX vaguely resembles HTML5 and CSSinJS - well, if you squint your eyes a little you might find things that sound familiar.","date":"2019-05-29T00:00:00.000Z","formattedDate":"May 29, 2019","tags":[{"label":"Development","permalink":"/blog/tags/development"}],"readingTime":6.195,"hasTruncateMarker":true,"authors":[{"name":"Mike Polinowski","title":"CTO INSTAR Deutschland GmbH","url":"https://github.com/mpolinowski","imageURL":"https://github.com/mpolinowski.png","key":"mpolinowski"}],"frontMatter":{"slug":"the-modern-web","title":"The Modern Web","authors":"mpolinowski","tags":["Development"]},"prevItem":{"title":"Application Development and Server Operation","permalink":"/blog/devops-introduction"},"nextItem":{"title":"MDX Blog Post","permalink":"/blog/mdx-blog-post"}},"content":"When websites stopped being simple fixed HTML layouts with hyperlinks they called it __Web 2.0__. What number are we at now? I must have lost count. I have learnt HTML5 and CSS3 on my own long before I had to use it professionally. And once I started being asked to provide solutions for web projects... those no longer seemed to matter much. Sure JSX vaguely resembles HTML5 and CSS`in`JS - well, if you squint your eyes a little you might find things that sound familiar.\\n\\n\x3c!--truncate--\x3e\\n\\n# The Modern Web\\n\\n\x3c!-- TOC --\x3e\\n\\n- [The Modern Web](#the-modern-web)\\n  - [Choose you Stack](#choose-you-stack)\\n  - [What makes a Web Application](#what-makes-a-web-application)\\n  - [Downfalls](#downfalls)\\n\\n\x3c!-- /TOC --\x3e\\n\\n\\n> The day the web changed - but did it become better?\\n\\n\\nWhen I got first in contact with web development in an professional setting I thought that it was very `clonky`, all those jQuery components were limiting and bleeding CSS an absolute nightmare. The first time that I felt love for something in the webdev field was due to my encounter with __Twitter Bootstrap__. Responsive web pages - I could not get enough of it. And the second time - __Facebook React__.\\n\\n\\nA modern website often resembles more a desktop application. Gone are the days of the destruction of the DOM between page loads. Clicking on buttons now loads the content you want to see without you having to stare at a white page transition. You type in a search query and the results appear, magically a few seconds later.\\n\\n\\n## Choose you Stack\\n\\nYour first step into the modern WebDev mine field can be daunting. Not only are there already thousands of libraries and hundreds of Frameworks that are in regular use in the industry. But there will be a new one every day in your inbox and some of them just look so tempting. You really want to add all of them to your web project and bedazzle your users as well as your coworkers.\\n\\nBut you will quickly learn that learning all of them is not an option - there are too many. And the quality and longevity of them varies widely. And then there is the job perspective - what libraries / frameworks are in demand in your area? You will not be able to pass the screening process if you lean to heavy on exotics.\\n\\nA stack is a combination of - let\'s call them - tools then can be combined to build a full-stack web application from top to bottom. An example is the __MERN Stack__. The acronym describes a tool stack consisting of:\\n\\n* __MongoDB__ for your page data__, \\n* __Express.js__ as a webserver for you application\\n* __React.js__ to build your frontend user interface and connect to your database\\n* __Node.js__ the backend that drives your application\\n\\n\\n## What makes a Web Application\\n\\nThe uninitiated use might be surfing amazon.com and still considering it to be a website. But on the other hand, if you show him a \\"real\\" website you cooked yourself in 5 minutes based on simple HTML/CSS + a fancy jQuery accordion for your site nav, he will probably not be impressed and agree that there is an obvious difference between them.\\n\\nSo what makes a website a web application? To be honest I don\'t know if there is a list you have to comply with. It is a very soft discriminator. For me, I have an image in my mind how a smartphone app or desktop application works. When a website shows a similar behaviour then it is a web application. What are tools that can give you the `application` _look&feel_ ?\\n\\n\\n* __Reactive Interface__: React, Angular, Vue und Co. allow you to write webpages that no longer navigate between pages. You whole application can be on a single URL (__SPA__; _Single Page Application_). Interaction that require your app to get new data now trigger a background service to take care of everything. Once the data arrives every element that relies on this new data will be re-rendered. The trick is now to break up your page into small components so that your user faces a mostly static interface - just like you would expect a desktop to behave.\\n* __Offline Support__: A smartphone app, even if it partly relies on an online API, can be launched and partly used when you are offline - only online features will result in an loading animation or error message. Websites have always been dead when you cut your internet. Not anymore! __Service Worker__ now take over the loading and caching of data from your web browser. Such a worker can be embedded inside your web app and cache the complete content making everything available offline. A use case would be a webUI for an IoT device. The data that has to be cached is minimal and it won\'t disturb your smartphones cache management system. Whenever you open the URL to your web cam, the interface will be available instantly - just like a native smartphone app. Service worker also add support for background downloads of new data, that will only be displayed once the download is completed.\\n* __API Interaction__: A webapp can interact with your backend and apply some logic to it. For example you can show different content based on user permission, fetch data from different sources and combine them in one dashboard, allow the user to interact with this data and send updates back to your backend services,...\\n\\n\\n## Downfalls\\n\\n> Should I now build Web Applications for everything?\\n\\n\\nYes, absolutely :)\\n\\n\\nSo what are the problems we might encounter with web apps? Surely there is a higher degree of complexity that needs to be created, maintained and executed. In general it is said that webapps are slow loading and this is true. When you enter a HTML webpage you only download whatever is displayed on that page. With a webapp you have to download the complete application code (think of downloading an `*.exe` file on Windows before you are able to start the application).\\n\\n\\nSo how can we solve those issues?\\n\\n\\n* __Complexity & Maintenance__: This is an issue. If you don\'t have a full-stack team in place that uses your choice of Stack to solve everything (so having the necessary experience) I would not recommend building a web application. The KISS principle applies.If you worry about your marketing team (without webdev experience) having to maintain the page content - that is not a problem. Once you have your application in place you can e.g. use Markdown to create new content - all you need for that is some MS Word skills (see. JAM Stack).\\n* __Slow First Page Prints__: If all you need is some static web content going with a web application was hard to recommend as download speeds take a bad hit once you add application logic. Of course only for the first page load - once everything is in place the application can dramatically improve your user experience. Even if it is just loading some static content in a very elegant way. The issue is solved once you start using __Server Side Rendering (SSR)__. Combining both worlds a SSR web application will first serve a static HTML version of itself and then start loading the application part in the background. The static version will be replaced by the interactive one as soon as the code download is completed."},{"id":"mdx-blog-post","metadata":{"permalink":"/blog/mdx-blog-post","editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/blog/2017-08-01-mdx-blog-post/index.mdx","source":"@site/blog/2017-08-01-mdx-blog-post/index.mdx","title":"MDX Blog Post","description":"Flip Cards","date":"2017-08-01T00:00:00.000Z","formattedDate":"August 1, 2017","tags":[{"label":"Markdown","permalink":"/blog/tags/markdown"}],"readingTime":0.88,"hasTruncateMarker":false,"authors":[{"name":"Mike Polinowski","title":"CTO INSTAR Deutschland GmbH","url":"https://github.com/mpolinowski","imageURL":"https://github.com/mpolinowski.png","key":"mpolinowski"}],"frontMatter":{"slug":"mdx-blog-post","title":"MDX Blog Post","authors":["mpolinowski"],"tags":["Markdown"]},"prevItem":{"title":"The Modern Web","permalink":"/blog/the-modern-web"}},"content":"import FlipCards from \'@site/src/components/FlipCards/Test.jsx\'\\n\\n\\n### Flip Cards\\n\\n<FlipCards />\\n\\n\\n:::tip\\n\\nUse the power of React to create interactive blog posts.\\n\\n```js\\n<button onClick={() => alert(\'button clicked!\')}>Click me!</button>\\n```\\n\\n<button onClick={() => alert(\'button clicked!\')}>Click me!</button>\\n\\n:::\\n\\n\\n:::warning\\n\\nSed suscipit dictum odio ultrices mollis. Donec in pellentesque lectus. Ut congue vitae urna id sollicitudin. Curabitur tempus elit odio, ut condimentum est ullamcorper a. Duis nisi dolor, commodo eget scelerisque et, sollicitudin ut lacus. Vivamus fringilla consequat auctor. Duis ornare vel leo lobortis sagittis. Etiam dignissim dui eget velit fringilla.\\n\\n:::\\n\\n\\n:::info\\n\\nMaecenas pellentesque leo eget neque aliquam, eget faucibus ipsum pharetra. Donec sed luctus risus. Nullam porta magna nulla, ut aliquet risus malesuada ac. Vestibulum semper, nisl accumsan accumsan maximus, tortor mauris dictum massa.\\n\\n:::\\n\\n\\n:::caution\\n\\nSed suscipit dictum odio ultrices mollis. Donec in pellentesque lectus. Ut congue vitae urna id sollicitudin. Curabitur tempus elit odio, ut condimentum est ullamcorper a. Duis nisi dolor, commodo eget scelerisque et, sollicitudin ut lacus. Vivamus fringilla consequat auctor. Duis ornare vel leo lobortis sagittis. Etiam dignissim dui eget velit fringilla.\\n\\n:::"}]}')}}]);