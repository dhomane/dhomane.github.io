"use strict";(self.webpackChunkmikes_dev_notebook=self.webpackChunkmikes_dev_notebook||[]).push([[32701],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},g=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),g=p(n),d=a,m=g["".concat(l,".").concat(d)]||g[d]||u[d]||o;return n?r.createElement(m,i(i({ref:t},c),{},{components:n})):r.createElement(m,i({ref:t},c))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=g;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}g.displayName="MDXCreateElement"},94479:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(87462),a=(n(67294),n(3905));const o={sidebar_position:9040,slug:"2021-09-21",title:"Getting started with Go and React - Webservice, Routing and Status Log",authors:"mpolinowski",tags:["Go"]},i=void 0,s={unversionedId:"Development/Go/2021-09-21--golang-react-starter-part-i/index",id:"Development/Go/2021-09-21--golang-react-starter-part-i/index",title:"Getting started with Go and React - Webservice, Routing and Status Log",description:"Shenzhen, China",source:"@site/docs/Development/Go/2021-09-21--golang-react-starter-part-i/index.md",sourceDirName:"Development/Go/2021-09-21--golang-react-starter-part-i",slug:"/Development/Go/2021-09-21--golang-react-starter-part-i/2021-09-21",permalink:"/docs/Development/Go/2021-09-21--golang-react-starter-part-i/2021-09-21",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/Development/Go/2021-09-21--golang-react-starter-part-i/index.md",tags:[{label:"Go",permalink:"/docs/tags/go"}],version:"current",sidebarPosition:9040,frontMatter:{sidebar_position:9040,slug:"2021-09-21",title:"Getting started with Go and React - Webservice, Routing and Status Log",authors:"mpolinowski",tags:["Go"]},sidebar:"tutorialSidebar",previous:{title:"Getting started with Go and React - API Routes",permalink:"/docs/Development/Go/2021-09-22--golang-react-starter-part-ii/2021-09-22"},next:{title:"Golang Refresher :: url & http",permalink:"/docs/Development/Go/2021-09-11--golang-refresher-network/2021-09-11"}},l={},p=[{value:"Basic Setup",id:"basic-setup",level:2},{value:"Configuration of the Webservice",id:"configuration-of-the-webservice",level:3},{value:"Adding a Router",id:"adding-a-router",level:3}],c={toc:p};function u(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Shenzhen, China",src:n(65419).Z,width:"1500",height:"441"})),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"Creating an REST API backend in Go and connecting it to a React.js frontend.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#"},"Part I - Webservice, Routing and Status Log")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#"},"Part II - API Routes")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#"},"Part III - PostgreSQL"))),(0,a.kt)("p",null,"I want to prototype a Go backend for a ",(0,a.kt)("strong",{parentName:"p"},"Weather Cam")," tool. The backend should hold all the information related to all cameras and serve them on different routes. The backend then needs to be connected to a React.js frontend that displays the JSON data that is being served as well as to allow to add / delete cameras."),(0,a.kt)("h2",{id:"basic-setup"},"Basic Setup"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"mkdir go_backend && cd go_backend\ngo mod init backend\n")),(0,a.kt)("h3",{id:"configuration-of-the-webservice"},"Configuration of the Webservice"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"./src/api/main.go")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "flag"\n    "fmt"\n    "log"\n    "net/http"\n)\n\n// App version\nconst version = "1.0.0"\n\ntype config struct {\n    // App configuration type\n    port int\n    env  string\n}\n\ntype AppStatus struct {\n    // Type for the status check\n    Status      string `json:"status"`\n    Environment string `json:"env"`\n    Version     string `json:"version"`\n}\n\nfunc main() {\n    // The app configuration is either given as a command line flag\n    // or set to a default value defined below\n    var cfg config\n    flag.IntVar(&cfg.port, "port", 4000, "Server port to listen on")\n    flag.StringVar(&cfg.env, "env", "development", "Application environment (development|production")\n    flag.Parse()\n    // Print config to console\n    fmt.Println("Backend (version", version, ") is running on port", cfg.port, "in", cfg.env, "mode.")\n    // Prepare a webservice handling the route `/status`\n    http.HandleFunc("/status", func(w http.ResponseWriter, r *http.Request) {\n        // Add status variables for the status check\n        currentStatus := AppStatus {\n            Status: "Ready",\n            Environment: cfg.env,\n            Version: version,\n        }\n        // Convert to JSON\n        js, err := json.MarshalIndent(currentStatus, "", "\\t")\n        if err != nil {\n            fmt.Println(err)\n        }\n        // Write JSON header, http Status code and status variables\n        w.Header().Set("Content-Type", "application/json")\n        w.WriteHeader(http.StatusOK)\n        w.Write(js)\n    })\n    // Start the webservice on the defined app port\n    err := http.ListenAndServe(fmt.Sprintf(":%d", cfg.port), nil)\n    if err != nil {\n        log.Println((err))\n    }\n}\n')),(0,a.kt)("p",null,"Test run:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run ./src/api/\nBackend (version 1.0.0 ) is running on port 4000 in development mode.\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'curl localhost:4000/status\n\n{\n"status": "Ready",\n"env": "development",\n"version": "1.0.0"\n}\n')),(0,a.kt)("h3",{id:"adding-a-router"},"Adding a Router"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/julienschmidt/httprouter"},"HttpRouter")," is a lightweight high performance HTTP request router (also called multiplexer or just mux for short) for Go."),(0,a.kt)("p",null,"In contrast to the default mux of Go's net/http package, this router supports variables in the routing pattern and matches against the request method. It also scales better."),(0,a.kt)("p",null,"The router is optimized for high performance and a small memory footprint. It scales well even with very long paths and a large number of routes. A compressing dynamic trie (radix tree) structure is used for efficient matching."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go get -u github.com/julienschmidt/httprouter\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Create an ",(0,a.kt)("inlineCode",{parentName:"li"},"application")," struct that holds the app configuration and a logger instance. This allows us to access those from other parts of our application."),(0,a.kt)("li",{parentName:"ol"},"Separate the HTTP GET request for the status route into a separate handler. Here we need the receiver to access the environment variable ",(0,a.kt)("inlineCode",{parentName:"li"},"app.config.env")," and print to the ",(0,a.kt)("inlineCode",{parentName:"li"},"app.logger.Println(err)"),".")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"./src/api/statusHandler.go"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "encoding/json"\n    "net/http"\n)\n\nfunc (app *application) statusHandler(w http.ResponseWriter, r *http.Request) {\n    // Add status variables for the status check\n    currentStatus := AppStatus {\n        Status: "ready",\n        // get environment from app receiver in main\n        Environment: app.config.env,\n        // Version is declared as a global variable in main\n        Version: version,\n    }\n    // Convert to JSON\n    js, err := json.MarshalIndent(currentStatus, "", "\\t")\n    if err != nil {\n        // get logger from app receiver in main\n        app.logger.Println(err)\n    }\n    // Write JSON header, http Status code and publish status variables\n    w.Header().Set("Content-Type", "application/json")\n    w.WriteHeader(http.StatusOK)\n    w.Write(js)\n\n}\n')),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Let ",(0,a.kt)("strong",{parentName:"li"},"HttpRouter")," handle the routing and call the correct handler for each route.")),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"./src/api/routes.go"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "net/http"\n\n    "github.com/julienschmidt/httprouter"\n)\n\nfunc (app *application) routes() *httprouter.Router {\n    // Create new router\n    router := httprouter.New()\n    // let router handle status route with statusHandler\n    router.HandlerFunc(http.MethodGet, "/status", app.statusHandler)\n\n    return router\n}\n')),(0,a.kt)("p",null,"Main now looks like:"),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"./src/api/main.go"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "flag"\n    "fmt"\n    "log"\n    "net/http"\n    "os"\n    "time"\n)\n\n// App version\nconst version = "1.0.0"\n\ntype config struct {\n    // App configuration type\n    port int\n    env  string\n}\n\ntype AppStatus struct {\n    // Type for the status check\n    Status      string `json:"status"`\n    Environment string `json:"env"`\n    Version     string `json:"version"`\n}\n\n\n// Receiver type to share informations with other\n// components. See `app` variable below\ntype application struct {\n    config config\n    logger *log.Logger\n}\n\nfunc main() {\n    // The app configuration is either given as a command line flag\n    // or set to a default value defined below\n    var cfg config\n    flag.IntVar(&cfg.port, "port", 4000, "Server port to listen on")\n    flag.StringVar(&cfg.env, "env", "dev", "Application environment (dev|prod")\n    flag.Parse()\n\n    // Create logger that writes stdout to console\n    logger := log.New(os.Stdout, "", log.Ldate|log.Ltime)\n\n    // application used as an receiver to make config\n    // variables and logger available in other parts\n    // of the application\n    app := &application {\n        config: cfg,\n        logger: logger,\n    }\n\n    srv := &http.Server {\n        Addr: fmt.Sprintf(":%d", cfg.port),\n        Handler: app.routes(),\n        IdleTimeout: time.Minute,\n        ReadTimeout: 10 * time.Second,\n        WriteTimeout: 30 * time.Second,\n    }\n\n    // Print config to console using logger\n    logger.Println("Backend (version", version, ") is starting on port", cfg.port, "in", cfg.env, "mode.")\n\n    // Start the webservice on the defined app port\n    err := srv.ListenAndServe()\n    if err != nil {\n        log.Println((err))\n    }\n}\n')),(0,a.kt)("p",null,"Test run the application with:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"go run ./src/api/\n2021/10/12 13:30:05 Backend (version 1.0.0 ) is starting on port 4000 in dev mode.\n")))}u.isMDXComponent=!0},65419:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/photo-kt443t6d_64hdh43hfh6dgjdfhg4_d-f4a66dcdd4723b20f63751871edc4e36.jpg"}}]);